/*
 * GAMS - General Algebraic Modeling System GDX API
 *
 * Copyright (c) 2017-2024 GAMS Software GmbH <support@gams.com>
 * Copyright (c) 2017-2024 GAMS Development Corp. <support@gams.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// WARNING: This file is generated by the "yaml2doxy" script from the API definition file "gdxapi.yaml"

#pragma once

#include "gxfile.h"

namespace gdx
{

/// @details Class for reading and writing GDX files through a efficient low-level interface
class TGXFileObj
{
public:
   /**
    * Constructor of GDX file object
    * @brief Create a new GDX file object. Does not open a file yet.
    * @param ErrMsg Out argument for storing potential error messages. Will be empty when there is no error.
     */
   explicit TGXFileObj( std::string &ErrMsg );

   /**
    * Destructor of GDX file object
    * @brief Dispose GDX file object.
    * @details Tears down a file GDX object and potentially closes (and flushes) a file opened for writing.
    */
   ~TGXFileObj();

   enum class TraceLevels
   {
      trl_none,
      trl_errors,
      trl_some,
      trl_all
   };
   void SetTraceLevel( TraceLevels tl );
{% for property in properties -%}
{%- set isread = property.action == 'r' %}
   /**
    * @brief {{beautify_html(property.description)}}
    * {% if isread %}@return 1 (true) iff. flag is set, 0 (false) otherwise.
      {%- else -%}@param flag 1 (true) to enable and 0 (false) to disable flag.{% endif %}
    */
   {% if isread -%}[[nodiscard]] int {% else %}void {% endif -%}
{{property.name}}{% if not isread %}Set{% endif %}({% if not isread %}int flag{%endif%}){% if isread %} const{% endif %};
{% endfor -%}

{% for group in groups -%}
{%- if group %}
   /// \name {{group}}
   /// @{
{%- endif -%}
{%- for function in gtf[group] -%}
    {%- set fobj = function.items()|first -%}
    {%- set fvals = fobj|last -%}
    {%- if fvals.details -%}
    {%- set triple = parse_details(fvals.details) -%}
    {%- endif %}
   /**
    * @brief {{ beautify_html(fvals.description) }}
    {%- if triple and triple[0].strip()|length > 0 %}
    * @details {{ triple[0] }}
    {%- endif -%}
    {%- for parm in fvals.parameters %}
    {%- set parm_vals = parm.values()|first %}
    * @param {{ parm|first }} {{ beautify_html(parm_vals.description) }}
    {%- endfor -%}
    {%- if triple and triple[3] %}
    * @note {{ triple[3] }}
    {%- endif -%}
    {%- if triple and triple[2] %}
    * @attention {{ triple[2] }}
    {%- endif -%}
    {%- if fvals.return %}
    * @return {{ beautify_html(fvals.return) }}
    {%- endif -%}
    {%- if fvals.code and fvals.code.cpp %}
    * @code
      {{ fvals.code.cpp|indent(6) }}
    * @endcode
    {%- endif -%}
    {%- if triple and triple[1] %}
    * @see {{ triple[1] }}
    {%- endif %}
    */
   {% if fvals.static %}static {% endif -%}{{ map_type(fobj|first, fvals.type) }}{{ fobj|first }}({% if fvals.parameters %}{{' '}}{% endif %}
   {%- for parm in fvals.parameters -%}
    {%- set parm_vals = parm.values()|first -%}
    {{map_type(fobj|first, parm_vals.type)}}{{parm|first}}{% if not loop.last %}, {% endif %}{% endfor -%}
    {%- if fvals.parameters %}{{' '}}{% endif %})
    {%- if fvals.const %} const{%- endif -%};
{% endfor %}
{%- if group %}
   /// @}

{% endif -%}
{% endfor %}

private:
std::unique_ptr<gmsstrm::TMiBufferedStreamDelphi> FFile;
TgxFileMode fmode { f_not_open }, fmode_AftReg { f_not_open };
enum
{
   stat_notopen,
   stat_read,
   stat_write
} fstatus { stat_notopen };
int fComprLev {};
std::unique_ptr<TUELTable> UELTable;
std::unique_ptr<TSetTextList> SetTextList {};
std::unique_ptr<int[]> MapSetText {};
int FCurrentDim {};
std::array<int, GLOBAL_MAX_INDEX_DIM> LastElem {}, PrevElem {}, MinElem {}, MaxElem {};
std::array<std::array<char, GLOBAL_UEL_IDENT_SIZE>, GLOBAL_MAX_INDEX_DIM> LastStrElem {};
int DataSize {};
tvarvaltype LastDataField {};
std::unique_ptr<TNameList> NameList;
std::unique_ptr<TDomainStrList> DomainStrList;
std::unique_ptr<LinkedDataType> SortList;
std::optional<LinkedDataIteratorType> ReadPtr;
std::unique_ptr<TTblGamsDataImpl<double>> ErrorList;
PgdxSymbRecord CurSyPtr {};
int ErrCnt {}, ErrCntTotal {};
int LastError {}, LastRepError {};
std::unique_ptr<TFilterList> FilterList;
TDFilter *CurFilter {};
TDomainList DomainList {};
bool StoreDomainSets { true }, AllowBogusDomain { true }, MapAcrToNaN {};
TIntlValueMapDbl intlValueMapDbl {}, readIntlValueMapDbl {};
TIntlValueMapI64 intlValueMapI64 {};
TraceLevels TraceLevel { TraceLevels::trl_all };
std::string TraceStr;
int VersionRead {};
std::string FProducer, FProducer2, FileSystemID;
int64_t MajorIndexPosition {};
int64_t NextWritePosition {};
int DataCount {}, NrMappedAdded {};
std::array<TgdxElemSize, GLOBAL_MAX_INDEX_DIM> ElemType {};
std::string MajContext;
std::array<TIntegerMapping, GLOBAL_MAX_INDEX_DIM> SliceIndxs {}, SliceRevMap {};
int SliceSyNr {};
std::array<std::string, GMS_MAX_INDEX_DIM> SliceElems;
bool DoUncompress {},  // when reading
        CompressOut {};// when writing
int DeltaForWrite {};  // delta for last dimension or first changed dimension
int DeltaForRead {};   // first position indicating change
double Zvalacr {};     // tricky
std::unique_ptr<TAcronymList> AcronymList;
std::array<TSetBitMap *, GLOBAL_MAX_INDEX_DIM> WrBitMaps {};
bool ReadUniverse {};
int UniverseNr {}, UelCntOrig {};// original uel count when we open the file
int AutoConvert { 1 };
int NextAutoAcronym {};
bool AppendActive {};

#ifndef VERBOSE_TRACE
const TraceLevels defaultTraceLevel { TraceLevels::trl_none };
const bool verboseTrace {};
#else
const TraceLevels defaultTraceLevel { TraceLevels::trl_all };
const bool verboseTrace { true };
#endif

//api wrapper magic for Fortran
TDataStoreFiltProc_t gdxDataReadRawFastFilt_DP {};
TDomainIndexProc_t gdxGetDomainElements_DP {};

bool PrepareSymbolWrite( std::string_view Caller, const char *AName, const char *AText, int ADim, int AType, int AUserInfo );
int PrepareSymbolRead( std::string_view Caller, int SyNr, const int *ADomainNrs, TgxFileMode newmode );

void InitErrors();
void SetError( int N );
void ReportError( int N );
bool ErrorCondition( bool cnd, int N );

bool MajorCheckMode( std::string_view Routine, TgxFileMode m );
bool MajorCheckMode( std::string_view Routine, const TgxModeSet &MS );

bool CheckMode( std::string_view Routine );
bool CheckMode( std::string_view Routine, TgxFileMode m );
bool CheckMode( std::string_view Routine, const TgxModeSet &MS );

void WriteTrace( std::string_view s ) const;
void InitDoWrite( int NrRecs );
bool DoWrite( const int *AElements, const double *AVals );
bool DoRead( double *AVals, int &AFDim );
void AddToErrorListDomErrs( const std::array<int, GLOBAL_MAX_INDEX_DIM> &AElements, const double *AVals );
void AddToErrorList( const int *AElements, const double *AVals );
void GetDefaultRecord( double *Avals ) const;
double AcronymRemap( double V );
bool IsGoodNewSymbol( const char *s );
bool ResultWillBeSorted( const int *ADomainNrs );

int gdxOpenReadXX( const char *Afn, int filemode, int ReadMode, int &ErrNr );

// This one is a helper function for a callback from a Fortran client
void gdxGetDomainElements_DP_FC( int RawIndex, int MappedIndex, void *Uptr );
int gdxDataReadRawFastFilt_DP_FC( const int *Indx, const double *Vals, void *Uptr );

void mapDefaultRecordValues(double *AVals) const;

public:
bool gdxGetDomainElements_DP_CallByRef {},
        gdxDataReadRawFastFilt_DP_CallByRef {},
        gdxDataReadRawFastEx_DP_CallByRef {};
};

}// namespace gdx
