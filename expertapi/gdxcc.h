/* gdxcc.h
 * Header file for C-style interface to the GDX library
 * generated by apiwrapper for GAMS Version 40.0.0
 *
 * GAMS - Loading mechanism for GAMS Expert-Level APIs
 *
 * Copyright (c) 2016-2022 GAMS Software GmbH <support@gams.com>
 * Copyright (c) 2016-2022 GAMS Development Corp. <support@gams.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


#if ! defined(_GDXCC_H_)
#     define  _GDXCC_H_

#define GDXAPIVERSION 8
#if defined(_WIN32) && defined(__GNUC__)
# include <stdio.h>
#endif


#include "gclgms.h"

#if defined(_WIN32)
# define GDX_CALLCONV __stdcall
#else
# define GDX_CALLCONV
#endif
#if defined(_WIN32)
typedef __int64 INT64;
#elif defined(__LP64__) || defined(__axu__) || defined(_FCGLU_LP64_)
typedef signed long int INT64;
#else
typedef signed long long int INT64;
#endif

#if defined(__cplusplus)
extern "C" {
#endif

struct gdxRec;
typedef struct gdxRec *gdxHandle_t;

typedef int (*gdxErrorCallback_t) (int ErrCount, const char *msg);

/* headers for "wrapper" routines implemented in C */
/** gdxGetReady: load library
 *  @return false on failure to load library, true on success 
 */
int gdxGetReady  (char *msgBuf, int msgBufLen);

/** gdxGetReadyD: load library from the speicified directory
 * @return false on failure to load library, true on success 
 */
int gdxGetReadyD (const char *dirName, char *msgBuf, int msgBufLen);

/** gdxGetReadyL: load library from the specified library name
 *  @return false on failure to load library, true on success 
 */
int gdxGetReadyL (const char *libName, char *msgBuf, int msgBufLen);

/** gdxCreate: load library and create gdx object handle 
 *  @return false on failure to load library, true on success 
 */
int gdxCreate    (gdxHandle_t *pgdx, char *msgBuf, int msgBufLen);

/** gdxCreateD: load library from the specified directory and create gdx object handle
 * @return false on failure to load library, true on success 
 */
int gdxCreateD   (gdxHandle_t *pgdx, const char *dirName, char *msgBuf, int msgBufLen);

/** gdxCreate: load library from the specified library name and create gdx object handle
 * @return false on failure to load library, true on success 
 */
int gdxCreateL   (gdxHandle_t *pgdx, const char *libName, char *msgBuf, int msgBufLen);

/** gdxFree: free gdx object handle 
 * @return false on failure, true on success 
 */
int gdxFree      (gdxHandle_t *pgdx);

/** Check if library has been loaded
 * @return false on failure, true on success 
 */
int gdxLibraryLoaded(void);

/** Check if library has been unloaded
 * @return false on failure, true on success 
 */
int gdxLibraryUnload(void);

/** Check if API and library have the same version, Library needs to be initialized before calling this.
 * @return true  (1) on success,
 *         false (0) on failure.
 */
int  gdxCorrectLibraryVersion(char *msgBuf, int msgBufLen);

int  gdxGetScreenIndicator   (void);
void gdxSetScreenIndicator   (int scrind);
int  gdxGetExceptionIndicator(void);
void gdxSetExceptionIndicator(int excind);
int  gdxGetExitIndicator     (void);
void gdxSetExitIndicator     (int extind);
gdxErrorCallback_t gdxGetErrorCallback(void);
void gdxSetErrorCallback(gdxErrorCallback_t func);
int  gdxGetAPIErrorCount     (void);
void gdxSetAPIErrorCount     (int ecnt);

void gdxErrorHandling(const char *msg);
void gdxInitMutexes(void);
void gdxFiniMutexes(void);

#if defined(GDX_MAIN)    /* we must define some things only once */
# define GDX_FUNCPTR(NAME)  NAME##_t NAME = NULL
#else
# define GDX_FUNCPTR(NAME)  extern NAME##_t NAME
#endif

/* function typedefs and pointer definitions */
typedef void (GDX_CALLCONV *TDataStoreProc_t) (const int Indx[], const double Vals[]);
typedef int (GDX_CALLCONV *TDataStoreFiltProc_t) (const int Indx[], const double Vals[], void *Uptr);
typedef void (GDX_CALLCONV *TDomainIndexProc_t) (int RawIndex, int MappedIndex, void *Uptr);

/* Prototypes for Dummy Functions */
int  GDX_CALLCONV d_gdxAcronymAdd (gdxHandle_t pgdx, const char *AName, const char *Txt, int AIndx);
int  GDX_CALLCONV d_gdxAcronymCount (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxAcronymGetInfo (gdxHandle_t pgdx, int N, char *AName, char *Txt, int *AIndx);
int  GDX_CALLCONV d_gdxAcronymGetMapping (gdxHandle_t pgdx, int N, int *orgIndx, int *newIndx, int *autoIndex);
int  GDX_CALLCONV d_gdxAcronymIndex (gdxHandle_t pgdx, double V);
int  GDX_CALLCONV d_gdxAcronymName (gdxHandle_t pgdx, double V, char *AName);
int  GDX_CALLCONV d_gdxAcronymNextNr (gdxHandle_t pgdx, int NV);
int  GDX_CALLCONV d_gdxAcronymSetInfo (gdxHandle_t pgdx, int N, const char *AName, const char *Txt, int AIndx);
double  GDX_CALLCONV d_gdxAcronymValue (gdxHandle_t pgdx, int AIndx);
int  GDX_CALLCONV d_gdxAddAlias (gdxHandle_t pgdx, const char *Id1, const char *Id2);
int  GDX_CALLCONV d_gdxAddSetText (gdxHandle_t pgdx, const char *Txt, int *TxtNr);
int  GDX_CALLCONV d_gdxAutoConvert (gdxHandle_t pgdx, int NV);
int  GDX_CALLCONV d_gdxClose (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxDataErrorCount (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxDataErrorRecord (gdxHandle_t pgdx, int RecNr, int KeyInt[], double Values[]);
int  GDX_CALLCONV d_gdxDataErrorRecordX (gdxHandle_t pgdx, int RecNr, int KeyInt[], double Values[]);
int  GDX_CALLCONV d_gdxDataReadDone (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxDataReadFilteredStart (gdxHandle_t pgdx, int SyNr, const int FilterAction[], int *NrRecs);
int  GDX_CALLCONV d_gdxDataReadMap (gdxHandle_t pgdx, int RecNr, int KeyInt[], double Values[], int *DimFrst);
int  GDX_CALLCONV d_gdxDataReadMapStart (gdxHandle_t pgdx, int SyNr, int *NrRecs);
int  GDX_CALLCONV d_gdxDataReadRaw (gdxHandle_t pgdx, int KeyInt[], double Values[], int *DimFrst);
int  GDX_CALLCONV d_gdxDataReadRawFast (gdxHandle_t pgdx, int SyNr, TDataStoreProc_t DP, int *NrRecs);
int  GDX_CALLCONV d_gdxDataReadRawFastFilt (gdxHandle_t pgdx, int SyNr, const char *UelFilterStr[], TDataStoreFiltProc_t DP);
int  GDX_CALLCONV d_gdxDataReadRawStart (gdxHandle_t pgdx, int SyNr, int *NrRecs);
int  GDX_CALLCONV d_gdxDataReadSlice (gdxHandle_t pgdx, const char *UelFilterStr[], int *Dimen, TDataStoreProc_t DP);
int  GDX_CALLCONV d_gdxDataReadSliceStart (gdxHandle_t pgdx, int SyNr, int ElemCounts[]);
int  GDX_CALLCONV d_gdxDataReadStr (gdxHandle_t pgdx, char *KeyStr[], double Values[], int *DimFrst);
int  GDX_CALLCONV d_gdxDataReadStrStart (gdxHandle_t pgdx, int SyNr, int *NrRecs);
int  GDX_CALLCONV d_gdxDataSliceUELS (gdxHandle_t pgdx, const int SliceKeyInt[], char *KeyStr[]);
int  GDX_CALLCONV d_gdxDataWriteDone (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxDataWriteMap (gdxHandle_t pgdx, const int KeyInt[], const double Values[]);
int  GDX_CALLCONV d_gdxDataWriteMapStart (gdxHandle_t pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
int  GDX_CALLCONV d_gdxDataWriteRaw (gdxHandle_t pgdx, const int KeyInt[], const double Values[]);
int  GDX_CALLCONV d_gdxDataWriteRawStart (gdxHandle_t pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
int  GDX_CALLCONV d_gdxDataWriteStr (gdxHandle_t pgdx, const char *KeyStr[], const double Values[]);
int  GDX_CALLCONV d_gdxDataWriteStrStart (gdxHandle_t pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
int  GDX_CALLCONV d_gdxGetDLLVersion (gdxHandle_t pgdx, char *V);
int  GDX_CALLCONV d_gdxErrorCount (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxErrorStr (gdxHandle_t pgdx, int ErrNr, char *ErrMsg);
int  GDX_CALLCONV d_gdxFileInfo (gdxHandle_t pgdx, int *FileVer, int *ComprLev);
int  GDX_CALLCONV d_gdxFileVersion (gdxHandle_t pgdx, char *FileStr, char *ProduceStr);
int  GDX_CALLCONV d_gdxFilterExists (gdxHandle_t pgdx, int FilterNr);
int  GDX_CALLCONV d_gdxFilterRegister (gdxHandle_t pgdx, int UelMap);
int  GDX_CALLCONV d_gdxFilterRegisterDone (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxFilterRegisterStart (gdxHandle_t pgdx, int FilterNr);
int  GDX_CALLCONV d_gdxFindSymbol (gdxHandle_t pgdx, const char *SyId, int *SyNr);
int  GDX_CALLCONV d_gdxGetElemText (gdxHandle_t pgdx, int TxtNr, char *Txt, int *Node);
int  GDX_CALLCONV d_gdxGetLastError (gdxHandle_t pgdx);
INT64  GDX_CALLCONV d_gdxGetMemoryUsed (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxGetSpecialValues (gdxHandle_t pgdx, double AVals[]);
int  GDX_CALLCONV d_gdxGetUEL (gdxHandle_t pgdx, int UelNr, char *Uel);
int  GDX_CALLCONV d_gdxMapValue (gdxHandle_t pgdx, double D, int *sv);
int  GDX_CALLCONV d_gdxOpenAppend (gdxHandle_t pgdx, const char *FileName, const char *Producer, int *ErrNr);
int  GDX_CALLCONV d_gdxOpenRead (gdxHandle_t pgdx, const char *FileName, int *ErrNr);
int  GDX_CALLCONV d_gdxOpenReadEx (gdxHandle_t pgdx, const char *FileName, int ReadMode, int *ErrNr);
int  GDX_CALLCONV d_gdxOpenWrite (gdxHandle_t pgdx, const char *FileName, const char *Producer, int *ErrNr);
int  GDX_CALLCONV d_gdxOpenWriteEx (gdxHandle_t pgdx, const char *FileName, const char *Producer, int Compr, int *ErrNr);
int  GDX_CALLCONV d_gdxResetSpecialValues (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxSetHasText (gdxHandle_t pgdx, int SyNr);
int  GDX_CALLCONV d_gdxSetReadSpecialValues (gdxHandle_t pgdx, const double AVals[]);
int  GDX_CALLCONV d_gdxSetSpecialValues (gdxHandle_t pgdx, const double AVals[]);
int  GDX_CALLCONV d_gdxSetTextNodeNr (gdxHandle_t pgdx, int TxtNr, int Node);
int  GDX_CALLCONV d_gdxSetTraceLevel (gdxHandle_t pgdx, int N, const char *s);
int  GDX_CALLCONV d_gdxSymbIndxMaxLength (gdxHandle_t pgdx, int SyNr, int LengthInfo[]);
int  GDX_CALLCONV d_gdxSymbMaxLength (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxSymbolAddComment (gdxHandle_t pgdx, int SyNr, const char *Txt);
int  GDX_CALLCONV d_gdxSymbolGetComment (gdxHandle_t pgdx, int SyNr, int N, char *Txt);
int  GDX_CALLCONV d_gdxSymbolGetDomain (gdxHandle_t pgdx, int SyNr, int DomainSyNrs[]);
int  GDX_CALLCONV d_gdxSymbolGetDomainX (gdxHandle_t pgdx, int SyNr, char *DomainIDs[]);
int  GDX_CALLCONV d_gdxSymbolDim (gdxHandle_t pgdx, int SyNr);
int  GDX_CALLCONV d_gdxSymbolInfo (gdxHandle_t pgdx, int SyNr, char *SyId, int *Dimen, int *Typ);
int  GDX_CALLCONV d_gdxSymbolInfoX (gdxHandle_t pgdx, int SyNr, int *RecCnt, int *UserInfo, char *ExplTxt);
int  GDX_CALLCONV d_gdxSymbolSetDomain (gdxHandle_t pgdx, const char *DomainIDs[]);
int  GDX_CALLCONV d_gdxSymbolSetDomainX (gdxHandle_t pgdx, int SyNr, const char *DomainIDs[]);
int  GDX_CALLCONV d_gdxSystemInfo (gdxHandle_t pgdx, int *SyCnt, int *UelCnt);
int  GDX_CALLCONV d_gdxUELMaxLength (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxUELRegisterDone (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxUELRegisterMap (gdxHandle_t pgdx, int UMap, const char *Uel);
int  GDX_CALLCONV d_gdxUELRegisterMapStart (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxUELRegisterRaw (gdxHandle_t pgdx, const char *Uel);
int  GDX_CALLCONV d_gdxUELRegisterRawStart (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxUELRegisterStr (gdxHandle_t pgdx, const char *Uel, int *UelNr);
int  GDX_CALLCONV d_gdxUELRegisterStrStart (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxUMFindUEL (gdxHandle_t pgdx, const char *Uel, int *UelNr, int *UelMap);
int  GDX_CALLCONV d_gdxUMUelGet (gdxHandle_t pgdx, int UelNr, char *Uel, int *UelMap);
int  GDX_CALLCONV d_gdxUMUelInfo (gdxHandle_t pgdx, int *UelCnt, int *HighMap);
int  GDX_CALLCONV d_gdxGetDomainElements (gdxHandle_t pgdx, int SyNr, int DimPos, int FilterNr, TDomainIndexProc_t DP, int *NrElem, void *Uptr);
int  GDX_CALLCONV d_gdxCurrentDim (gdxHandle_t pgdx);
int  GDX_CALLCONV d_gdxRenameUEL (gdxHandle_t pgdx, const char *OldName, const char *NewName);
int  GDX_CALLCONV d_gdxStoreDomainSets (gdxHandle_t pgdx);
void GDX_CALLCONV d_gdxStoreDomainSetsSet (gdxHandle_t pgdx, const int x);


typedef int  (GDX_CALLCONV *gdxAcronymAdd_t) (gdxHandle_t pgdx, const char *AName, const char *Txt, int AIndx);
/** Add a new acronym entry. This can be used to add entries before data is written. =<0 if the entry is not added.
 *
 * @param pgdx gdx object handle
 * @param AName Name of the acronym
 * @param Txt Explanatory text of the acronym (gdxAcronym...)/String to be registered(gdxAddSetText)/Text found for the entry (gdxGetElemText)/String to add (gdxSymbolAddComment)/String containing requested line(gdxSymbolGetComment)
 * @param AIndx Index value of the acronym
 */
GDX_FUNCPTR(gdxAcronymAdd);

typedef int  (GDX_CALLCONV *gdxAcronymCount_t) (gdxHandle_t pgdx);
/** Number of entries in the acronym table.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxAcronymCount);

typedef int  (GDX_CALLCONV *gdxAcronymGetInfo_t) (gdxHandle_t pgdx, int N, char *AName, char *Txt, int *AIndx);
/** Retrieve acronym information from the acronym table. <>0 if the index into the acronym table is valid.
 *
 * @param pgdx gdx object handle
 * @param N Index number/Tracing level,  N=<0 no tracing  N>=3 maximum tracing (gdxSetTraceLevel)/Line number (gdxSymbolGetComment)
 * @param AName Name of the acronym
 * @param Txt Explanatory text of the acronym (gdxAcronym...)/String to be registered(gdxAddSetText)/Text found for the entry (gdxGetElemText)/String to add (gdxSymbolAddComment)/String containing requested line(gdxSymbolGetComment)
 * @param AIndx Index value of the acronym
 */
GDX_FUNCPTR(gdxAcronymGetInfo);

typedef int  (GDX_CALLCONV *gdxAcronymGetMapping_t) (gdxHandle_t pgdx, int N, int *orgIndx, int *newIndx, int *autoIndex);
/** Get information how acronym values are remapped. When reading gdx data, we need to map indices for acronyms used in the gdx file to indices used by the reading program. <>0 if the index into the acronym table is valid.
 *
 * @param pgdx gdx object handle
 * @param N Index number/Tracing level,  N=<0 no tracing  N>=3 maximum tracing (gdxSetTraceLevel)/Line number (gdxSymbolGetComment)
 * @param orgIndx The Index used in the gdx file
 * @param newIndx The Index returned when reading gdx data
 * @param autoIndex Nonzero if the newIndx was generated using the value of NextAutoAcronym
 */
GDX_FUNCPTR(gdxAcronymGetMapping);

typedef int  (GDX_CALLCONV *gdxAcronymIndex_t) (gdxHandle_t pgdx, double V);
/** Get index value of an acronym. 0 if V does not represent an acronym.
 *
 * @param pgdx gdx object handle
 * @param V Input value, possibly representing an acronym/Version string after return (gdxGetDLLVersion)
 */
GDX_FUNCPTR(gdxAcronymIndex);

typedef int  (GDX_CALLCONV *gdxAcronymName_t) (gdxHandle_t pgdx, double V, char *AName);
/** Find the name of an acronym value. <>0 if a name for the acronym is defined. An unnamed acronym value will return a string of the form UnknownAcronymNNN, were NNN is the index of the acronym.
 *
 * @param pgdx gdx object handle
 * @param V Input value, possibly representing an acronym/Version string after return (gdxGetDLLVersion)
 * @param AName Name of the acronym
 */
GDX_FUNCPTR(gdxAcronymName);

typedef int  (GDX_CALLCONV *gdxAcronymNextNr_t) (gdxHandle_t pgdx, int NV);
/** Returns the value of the NextAutoAcronym variable and sets the variable to NV. When we read from a gdx file and encounter an acronym that was not defined, we need to assign a new index for that acronym. That index is the variable NextAutoAcronym.
 *
 * @param pgdx gdx object handle
 * @param NV New value
 */
GDX_FUNCPTR(gdxAcronymNextNr);

typedef int  (GDX_CALLCONV *gdxAcronymSetInfo_t) (gdxHandle_t pgdx, int N, const char *AName, const char *Txt, int AIndx);
/** Modify acronym information in the acronym table. When reading (writing) a gdx file, this function is used to provide the acronym index (name of an acronym), the SyId (AIndx) parameter must match.
 *
 * @param pgdx gdx object handle
 * @param N Index number/Tracing level,  N=<0 no tracing  N>=3 maximum tracing (gdxSetTraceLevel)/Line number (gdxSymbolGetComment)
 * @param AName Name of the acronym
 * @param Txt Explanatory text of the acronym (gdxAcronym...)/String to be registered(gdxAddSetText)/Text found for the entry (gdxGetElemText)/String to add (gdxSymbolAddComment)/String containing requested line(gdxSymbolGetComment)
 * @param AIndx Index value of the acronym
 */
GDX_FUNCPTR(gdxAcronymSetInfo);

typedef double  (GDX_CALLCONV *gdxAcronymValue_t) (gdxHandle_t pgdx, int AIndx);
/** Create an acronym value based on the index (AIndx should be greater than 0). Returns the calculated acronym value (0 if AIndx =<0).
 *
 * @param pgdx gdx object handle
 * @param AIndx Index value of the acronym
 */
GDX_FUNCPTR(gdxAcronymValue);

typedef int  (GDX_CALLCONV *gdxAddAlias_t) (gdxHandle_t pgdx, const char *Id1, const char *Id2);
/** Add an alias for a set to the symbol table. One of the two identifiers has to be a known set, the other identifier is used as the new alias. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param Id1 Set identifier
 * @param Id2 Set identifier
 */
GDX_FUNCPTR(gdxAddAlias);

typedef int  (GDX_CALLCONV *gdxAddSetText_t) (gdxHandle_t pgdx, const char *Txt, int *TxtNr);
/** Register a string to be used as text associated with a unique element. The string must follow the GAMS syntax rules for explanatory text. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param Txt Explanatory text of the acronym (gdxAcronym...)/String to be registered(gdxAddSetText)/Text found for the entry (gdxGetElemText)/String to add (gdxSymbolAddComment)/String containing requested line(gdxSymbolGetComment)
 * @param TxtNr The index number assigned to this string (gdxAddSetText)/String table index (gdxGetElemText)/Index number of the entry to be modified (gdxSetTextNodeNr)
 */
GDX_FUNCPTR(gdxAddSetText);

typedef int  (GDX_CALLCONV *gdxAutoConvert_t) (gdxHandle_t pgdx, int NV);
/** Returns the value of the AutoConvert variable and sets the variable to NV. If AutoConvert <>0 when closing a new gdx file we look at the GDXCOMPRESS and GDXCONVERT environment variables to determine if conversion to an older file format is desired.
 *
 * @param pgdx gdx object handle
 * @param NV New value
 */
GDX_FUNCPTR(gdxAutoConvert);

typedef int  (GDX_CALLCONV *gdxClose_t) (gdxHandle_t pgdx);
/** Close a gdx file that was previously opened for reading or writing. Any pending write operations will be finished before closing
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxClose);

typedef int  (GDX_CALLCONV *gdxDataErrorCount_t) (gdxHandle_t pgdx);
/** The number of error records after a write operation is finished (gdxDataWriteDone).
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxDataErrorCount);

typedef int  (GDX_CALLCONV *gdxDataErrorRecord_t) (gdxHandle_t pgdx, int RecNr, int KeyInt[], double Values[]);
/** Retrieve an error record. <>0 if the record number is valid.
 *
 * @param pgdx gdx object handle
 * @param RecNr The number of the record to be retrieved, range from 1 to NrErrorRecords; this argument is ignored in gdxDataReadMap
 * @param KeyInt Index of the record/element
 * @param Values Values of the element (gdxDataWrite...)/Data of the record (gdxDataRead..., gdxDataErrorRecord)
 */
GDX_FUNCPTR(gdxDataErrorRecord);

typedef int  (GDX_CALLCONV *gdxDataErrorRecordX_t) (gdxHandle_t pgdx, int RecNr, int KeyInt[], double Values[]);
/** Retrieve an error record. <>0 if the record number is valid.
 *
 * @param pgdx gdx object handle
 * @param RecNr The number of the record to be retrieved, range from 1 to NrErrorRecords; this argument is ignored in gdxDataReadMap
 * @param KeyInt Index of the record/element
 * @param Values Values of the element (gdxDataWrite...)/Data of the record (gdxDataRead..., gdxDataErrorRecord)
 */
GDX_FUNCPTR(gdxDataErrorRecordX);

typedef int  (GDX_CALLCONV *gdxDataReadDone_t) (gdxHandle_t pgdx);
/** Finish reading of a symbol in any mode(raw, mapped, string). 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxDataReadDone);

typedef int  (GDX_CALLCONV *gdxDataReadFilteredStart_t) (gdxHandle_t pgdx, int SyNr, const int FilterAction[], int *NrRecs);
/** Initialize the reading of a symbol in filtered mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param FilterAction Array of filter actions for each index position
 * @param NrRecs The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read.
 */
GDX_FUNCPTR(gdxDataReadFilteredStart);

typedef int  (GDX_CALLCONV *gdxDataReadMap_t) (gdxHandle_t pgdx, int RecNr, int KeyInt[], double Values[], int *DimFrst);
/** Read the next record in mapped mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param RecNr The number of the record to be retrieved, range from 1 to NrErrorRecords; this argument is ignored in gdxDataReadMap
 * @param KeyInt Index of the record/element
 * @param Values Values of the element (gdxDataWrite...)/Data of the record (gdxDataRead..., gdxDataErrorRecord)
 * @param DimFrst The first index position in KeyInt that changed
 */
GDX_FUNCPTR(gdxDataReadMap);

typedef int  (GDX_CALLCONV *gdxDataReadMapStart_t) (gdxHandle_t pgdx, int SyNr, int *NrRecs);
/** Initialize the reading of a symbol in mapped mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param NrRecs The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read.
 */
GDX_FUNCPTR(gdxDataReadMapStart);

typedef int  (GDX_CALLCONV *gdxDataReadRaw_t) (gdxHandle_t pgdx, int KeyInt[], double Values[], int *DimFrst);
/** Read the next record in raw mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param KeyInt Index of the record/element
 * @param Values Values of the element (gdxDataWrite...)/Data of the record (gdxDataRead..., gdxDataErrorRecord)
 * @param DimFrst The first index position in KeyInt that changed
 */
GDX_FUNCPTR(gdxDataReadRaw);

typedef int  (GDX_CALLCONV *gdxDataReadRawFast_t) (gdxHandle_t pgdx, int SyNr, TDataStoreProc_t DP, int *NrRecs);
/** Read a symbol in Raw mode using a callback procedure. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param DP Callback procedure that will be called for each item
 * @param NrRecs The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read.
 */
GDX_FUNCPTR(gdxDataReadRawFast);

typedef int  (GDX_CALLCONV *gdxDataReadRawFastFilt_t) (gdxHandle_t pgdx, int SyNr, const char *UelFilterStr[], TDataStoreFiltProc_t DP);
/** Read a symbol in Raw mode while applying a filter using a callback procedure. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param UelFilterStr Each index can be fixed by setting the string for the unique element. Set an index position to the empty string in order not to fix that position.
 * @param DP Callback procedure that will be called for each item
 */
GDX_FUNCPTR(gdxDataReadRawFastFilt);

typedef int  (GDX_CALLCONV *gdxDataReadRawStart_t) (gdxHandle_t pgdx, int SyNr, int *NrRecs);
/** Initialize the reading of a symbol in raw mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param NrRecs The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read.
 */
GDX_FUNCPTR(gdxDataReadRawStart);

typedef int  (GDX_CALLCONV *gdxDataReadSlice_t) (gdxHandle_t pgdx, const char *UelFilterStr[], int *Dimen, TDataStoreProc_t DP);
/** Read a slice of data from a data set, by fixing zero or more index positions in the data. When a data element is available, the callback procedure DP is called with the current index and the values. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param UelFilterStr Each index can be fixed by setting the string for the unique element. Set an index position to the empty string in order not to fix that position.
 * @param Dimen Dimension of the symbol/index space; index space means the number of index positions that is not fixed (gdxDataReadSlice)
 * @param DP Callback procedure that will be called for each item
 */
GDX_FUNCPTR(gdxDataReadSlice);

typedef int  (GDX_CALLCONV *gdxDataReadSliceStart_t) (gdxHandle_t pgdx, int SyNr, int ElemCounts[]);
/** Prepare for the reading of a slice of data from a data set. The actual read of the data is done by calling gdxDataReadSlice. When finished reading, call gdxDataReadDone. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param ElemCounts Array of integers, each position indicating the number of unique indices in that position
 */
GDX_FUNCPTR(gdxDataReadSliceStart);

typedef int  (GDX_CALLCONV *gdxDataReadStr_t) (gdxHandle_t pgdx, char *KeyStr[], double Values[], int *DimFrst);
/** Read the next record using strings for the unique elements. The reading should be initialized by calling DataReadStrStart. 0 if the operation is not possible or if there is no more data.
 *
 * @param pgdx gdx object handle
 * @param KeyStr The index of the record or element using strings for the unique elements/Array of strings containing the unique elements (gdxDataSliceUELS)
 * @param Values Values of the element (gdxDataWrite...)/Data of the record (gdxDataRead..., gdxDataErrorRecord)
 * @param DimFrst The first index position in KeyInt that changed
 */
GDX_FUNCPTR(gdxDataReadStr);

typedef int  (GDX_CALLCONV *gdxDataReadStrStart_t) (gdxHandle_t pgdx, int SyNr, int *NrRecs);
/** Initialize the reading of a symbol in string mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param NrRecs The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read.
 */
GDX_FUNCPTR(gdxDataReadStrStart);

typedef int  (GDX_CALLCONV *gdxDataSliceUELS_t) (gdxHandle_t pgdx, const int SliceKeyInt[], char *KeyStr[]);
/** Map a slice index into the corresponding unique elements. After calling DataReadSliceStart, index positions are mapped from 0 to N(d)-1. This function maps this index space back into unique elements (strings). 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SliceKeyInt The slice index to be mapped to strings
 * @param KeyStr The index of the record or element using strings for the unique elements/Array of strings containing the unique elements (gdxDataSliceUELS)
 */
GDX_FUNCPTR(gdxDataSliceUELS);

typedef int  (GDX_CALLCONV *gdxDataWriteDone_t) (gdxHandle_t pgdx);
/** Finish a write operation. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxDataWriteDone);

typedef int  (GDX_CALLCONV *gdxDataWriteMap_t) (gdxHandle_t pgdx, const int KeyInt[], const double Values[]);
/** Write a data element in mapped mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param KeyInt Index of the record/element
 * @param Values Values of the element (gdxDataWrite...)/Data of the record (gdxDataRead..., gdxDataErrorRecord)
 */
GDX_FUNCPTR(gdxDataWriteMap);

typedef int  (GDX_CALLCONV *gdxDataWriteMapStart_t) (gdxHandle_t pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
/** Start writing a new symbol in mapped mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyId Name of the acronym/symbol; might be an empty string at gdxAcronymName
 * @param ExplTxt Explanatory text for the symbol
 * @param Dimen Dimension of the symbol/index space; index space means the number of index positions that is not fixed (gdxDataReadSlice)
 * @param Typ Type of the symbol
 * @param UserInfo Any integer value/User field value (gdxSymbolInfoX)
 */
GDX_FUNCPTR(gdxDataWriteMapStart);

typedef int  (GDX_CALLCONV *gdxDataWriteRaw_t) (gdxHandle_t pgdx, const int KeyInt[], const double Values[]);
/** Write a data element in raw mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param KeyInt Index of the record/element
 * @param Values Values of the element (gdxDataWrite...)/Data of the record (gdxDataRead..., gdxDataErrorRecord)
 */
GDX_FUNCPTR(gdxDataWriteRaw);

typedef int  (GDX_CALLCONV *gdxDataWriteRawStart_t) (gdxHandle_t pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
/** Start writing a new symbol in raw mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyId Name of the acronym/symbol; might be an empty string at gdxAcronymName
 * @param ExplTxt Explanatory text for the symbol
 * @param Dimen Dimension of the symbol/index space; index space means the number of index positions that is not fixed (gdxDataReadSlice)
 * @param Typ Type of the symbol
 * @param UserInfo Any integer value/User field value (gdxSymbolInfoX)
 */
GDX_FUNCPTR(gdxDataWriteRawStart);

typedef int  (GDX_CALLCONV *gdxDataWriteStr_t) (gdxHandle_t pgdx, const char *KeyStr[], const double Values[]);
/** Write a data element in string mode. Each element string must follow the GAMS rules for unique elements. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param KeyStr The index of the record or element using strings for the unique elements/Array of strings containing the unique elements (gdxDataSliceUELS)
 * @param Values Values of the element (gdxDataWrite...)/Data of the record (gdxDataRead..., gdxDataErrorRecord)
 */
GDX_FUNCPTR(gdxDataWriteStr);

typedef int  (GDX_CALLCONV *gdxDataWriteStrStart_t) (gdxHandle_t pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
/** Start writing a new symbol in string mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyId Name of the acronym/symbol; might be an empty string at gdxAcronymName
 * @param ExplTxt Explanatory text for the symbol
 * @param Dimen Dimension of the symbol/index space; index space means the number of index positions that is not fixed (gdxDataReadSlice)
 * @param Typ Type of the symbol
 * @param UserInfo Any integer value/User field value (gdxSymbolInfoX)
 */
GDX_FUNCPTR(gdxDataWriteStrStart);

typedef int  (GDX_CALLCONV *gdxGetDLLVersion_t) (gdxHandle_t pgdx, char *V);
/** Returns a version descriptor of the library. Always nonzero
 *
 * @param pgdx gdx object handle
 * @param V Input value, possibly representing an acronym/Version string after return (gdxGetDLLVersion)
 */
GDX_FUNCPTR(gdxGetDLLVersion);

typedef int  (GDX_CALLCONV *gdxErrorCount_t) (gdxHandle_t pgdx);
/** Total number of errors encountered.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxErrorCount);

typedef int  (GDX_CALLCONV *gdxErrorStr_t) (gdxHandle_t pgdx, int ErrNr, char *ErrMsg);
/** Returns the text for a given error number. Always nonzero.
 *
 * @param pgdx gdx object handle
 * @param ErrNr Error number (gdxErrorStr)/Error code or zero if there is no error
 * @param ErrMsg Error text
 */
GDX_FUNCPTR(gdxErrorStr);

typedef int  (GDX_CALLCONV *gdxFileInfo_t) (gdxHandle_t pgdx, int *FileVer, int *ComprLev);
/** Returns file format number and compression level used. Always nonzero.
 *
 * @param pgdx gdx object handle
 * @param FileVer File format number or zero if the file is not open
 * @param ComprLev Compression used; 0=no compression, 1=zlib
 */
GDX_FUNCPTR(gdxFileInfo);

typedef int  (GDX_CALLCONV *gdxFileVersion_t) (gdxHandle_t pgdx, char *FileStr, char *ProduceStr);
/** Return strings for file version and file producer. Always nonzero.
 *
 * @param pgdx gdx object handle
 * @param FileStr Version string
 * @param ProduceStr Producer string
 */
GDX_FUNCPTR(gdxFileVersion);

typedef int  (GDX_CALLCONV *gdxFilterExists_t) (gdxHandle_t pgdx, int FilterNr);
/** Check if there is a filter defined based on its number as used in gdxFilterRegisterStart. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param FilterNr Filter number
 */
GDX_FUNCPTR(gdxFilterExists);

typedef int  (GDX_CALLCONV *gdxFilterRegister_t) (gdxHandle_t pgdx, int UelMap);
/** Add a unique element to the current filter definition. 0 if the index number is out of range or was never mapped into the user index space.
 *
 * @param pgdx gdx object handle
 * @param UelMap Unique element number in the user index space or -1 if element was never mapped
 */
GDX_FUNCPTR(gdxFilterRegister);

typedef int  (GDX_CALLCONV *gdxFilterRegisterDone_t) (gdxHandle_t pgdx);
/** Finish registration of unique elements for a filter. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxFilterRegisterDone);

typedef int  (GDX_CALLCONV *gdxFilterRegisterStart_t) (gdxHandle_t pgdx, int FilterNr);
/** Define a unique element filter. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param FilterNr Filter number
 */
GDX_FUNCPTR(gdxFilterRegisterStart);

typedef int  (GDX_CALLCONV *gdxFindSymbol_t) (gdxHandle_t pgdx, const char *SyId, int *SyNr);
/** Search for a symbol by name (case insensitive). When the symbol is found, SyNr contains the symbol number and the function returns a nonzero, else it returns 0.
 *
 * @param pgdx gdx object handle
 * @param SyId Name of the acronym/symbol; might be an empty string at gdxAcronymName
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 */
GDX_FUNCPTR(gdxFindSymbol);

typedef int  (GDX_CALLCONV *gdxGetElemText_t) (gdxHandle_t pgdx, int TxtNr, char *Txt, int *Node);
/** Retrieve the string and node number for an entry in the string table. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param TxtNr The index number assigned to this string (gdxAddSetText)/String table index (gdxGetElemText)/Index number of the entry to be modified (gdxSetTextNodeNr)
 * @param Txt Explanatory text of the acronym (gdxAcronym...)/String to be registered(gdxAddSetText)/Text found for the entry (gdxGetElemText)/String to add (gdxSymbolAddComment)/String containing requested line(gdxSymbolGetComment)
 * @param Node Node number of the entry (gdxGetElemText)/New Node value for the entry (gdxSetTextNodeNr)
 */
GDX_FUNCPTR(gdxGetElemText);

typedef int  (GDX_CALLCONV *gdxGetLastError_t) (gdxHandle_t pgdx);
/** Returns the last error number or 0 if there was no error. Calling this function will clear the last error stored.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxGetLastError);

typedef INT64  (GDX_CALLCONV *gdxGetMemoryUsed_t) (gdxHandle_t pgdx);
/** Get memory in use by gdx object.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxGetMemoryUsed);

typedef int  (GDX_CALLCONV *gdxGetSpecialValues_t) (gdxHandle_t pgdx, double AVals[]);
/** Retrieve the internal values for special values. Always nonzero.
 *
 * @param pgdx gdx object handle
 * @param AVals Array of special values used for Eps, +Inf, -Inf, NA and Undef
 */
GDX_FUNCPTR(gdxGetSpecialValues);

typedef int  (GDX_CALLCONV *gdxGetUEL_t) (gdxHandle_t pgdx, int UelNr, char *Uel);
/** Get the string for a unique element using a mapped index. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param UelNr Internal unique element number or -1 if not found
 * @param Uel String for the unique element
 */
GDX_FUNCPTR(gdxGetUEL);

typedef int  (GDX_CALLCONV *gdxMapValue_t) (gdxHandle_t pgdx, double D, int *sv);
/** Classify a value as a potential special value. Nonzero if D is a special value, 0 otherwise.
 *
 * @param pgdx gdx object handle
 * @param D Value to classify
 * @param sv Classification
 */
GDX_FUNCPTR(gdxMapValue);

typedef int  (GDX_CALLCONV *gdxOpenAppend_t) (gdxHandle_t pgdx, const char *FileName, const char *Producer, int *ErrNr);
/** Open an existing gdx file for output. Nonzero if the file can be opened, 0 otherwise.
 *
 * @param pgdx gdx object handle
 * @param FileName File name of the gdx file to be opened
 * @param Producer Name of program that appends to/creates the gdx file
 * @param ErrNr Error number (gdxErrorStr)/Error code or zero if there is no error
 */
GDX_FUNCPTR(gdxOpenAppend);

typedef int  (GDX_CALLCONV *gdxOpenRead_t) (gdxHandle_t pgdx, const char *FileName, int *ErrNr);
/** Open an existing gdx file for input. Nonzero if the file can be opened, 0 otherwise.
 *
 * @param pgdx gdx object handle
 * @param FileName File name of the gdx file to be opened
 * @param ErrNr Error number (gdxErrorStr)/Error code or zero if there is no error
 */
GDX_FUNCPTR(gdxOpenRead);

typedef int  (GDX_CALLCONV *gdxOpenReadEx_t) (gdxHandle_t pgdx, const char *FileName, int ReadMode, int *ErrNr);
/** Open an existing gdx file for input allowing for skiping sections. Nonzero if the file can be opened, 0 otherwise.
 *
 * @param pgdx gdx object handle
 * @param FileName File name of the gdx file to be opened
 * @param ReadMode Bitmap to skip reading section 0-bit: strings
 * @param ErrNr Error number (gdxErrorStr)/Error code or zero if there is no error
 */
GDX_FUNCPTR(gdxOpenReadEx);

typedef int  (GDX_CALLCONV *gdxOpenWrite_t) (gdxHandle_t pgdx, const char *FileName, const char *Producer, int *ErrNr);
/** Open a new gdx file for output. Nonzero if the file can be opened, 0 otherwise.
 *
 * @param pgdx gdx object handle
 * @param FileName File name of the gdx file to be opened
 * @param Producer Name of program that appends to/creates the gdx file
 * @param ErrNr Error number (gdxErrorStr)/Error code or zero if there is no error
 */
GDX_FUNCPTR(gdxOpenWrite);

typedef int  (GDX_CALLCONV *gdxOpenWriteEx_t) (gdxHandle_t pgdx, const char *FileName, const char *Producer, int Compr, int *ErrNr);
/** Open a new gdx file for output with optional compression. Nonzero if the file can be opened, 0 otherwise.
 *
 * @param pgdx gdx object handle
 * @param FileName File name of the gdx file to be opened
 * @param Producer Name of program that appends to/creates the gdx file
 * @param Compr Zero for no compression; nonzero uses compression if available
 * @param ErrNr Error number (gdxErrorStr)/Error code or zero if there is no error
 */
GDX_FUNCPTR(gdxOpenWriteEx);

typedef int  (GDX_CALLCONV *gdxResetSpecialValues_t) (gdxHandle_t pgdx);
/** Reset the internal values for special values. Always nonzero.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxResetSpecialValues);

typedef int  (GDX_CALLCONV *gdxSetHasText_t) (gdxHandle_t pgdx, int SyNr);
/** Test if any of the unique elements in a set has associated text. Nonzero if the Set contains at least one unique element that has associated text, 0 otherwise
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 */
GDX_FUNCPTR(gdxSetHasText);

typedef int  (GDX_CALLCONV *gdxSetReadSpecialValues_t) (gdxHandle_t pgdx, const double AVals[]);
/** Set internal values for special values when reading a gdx file. Before calling this function, initialize the array of special values by calling gdxGetSpecialValues first. Always nonzero
 *
 * @param pgdx gdx object handle
 * @param AVals Array of special values used for Eps, +Inf, -Inf, NA and Undef
 */
GDX_FUNCPTR(gdxSetReadSpecialValues);

typedef int  (GDX_CALLCONV *gdxSetSpecialValues_t) (gdxHandle_t pgdx, const double AVals[]);
/** Set internal values for special values. Before calling this function, initialize the array of special values by calling gdxGetSpecialValues first. Note, values in AVals have to be unique. Nonzero if all values specified are unique, 0 otherwise.
 *
 * @param pgdx gdx object handle
 * @param AVals Array of special values used for Eps, +Inf, -Inf, NA and Undef
 */
GDX_FUNCPTR(gdxSetSpecialValues);

typedef int  (GDX_CALLCONV *gdxSetTextNodeNr_t) (gdxHandle_t pgdx, int TxtNr, int Node);
/** Set the Node number for an entry with Index N in the string table. After registering a string with AddSetText, we can assign a node number for later retrieval. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param TxtNr The index number assigned to this string (gdxAddSetText)/String table index (gdxGetElemText)/Index number of the entry to be modified (gdxSetTextNodeNr)
 * @param Node Node number of the entry (gdxGetElemText)/New Node value for the entry (gdxSetTextNodeNr)
 */
GDX_FUNCPTR(gdxSetTextNodeNr);

typedef int  (GDX_CALLCONV *gdxSetTraceLevel_t) (gdxHandle_t pgdx, int N, const char *s);
/** Set the amount of trace (debug) information generated. Always nonzero.
 *
 * @param pgdx gdx object handle
 * @param N Index number/Tracing level,  N=<0 no tracing  N>=3 maximum tracing (gdxSetTraceLevel)/Line number (gdxSymbolGetComment)
 * @param s String to be included in trace output(gdxSetTraceLevel)
 */
GDX_FUNCPTR(gdxSetTraceLevel);

typedef int  (GDX_CALLCONV *gdxSymbIndxMaxLength_t) (gdxHandle_t pgdx, int SyNr, int LengthInfo[]);
/** Returns the length of the longest UEL used for every index position for a given symbol.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param LengthInfo The longest length for each index position
 */
GDX_FUNCPTR(gdxSymbIndxMaxLength);

typedef int  (GDX_CALLCONV *gdxSymbMaxLength_t) (gdxHandle_t pgdx);
/** Returns the length of the longest symbol name.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxSymbMaxLength);

typedef int  (GDX_CALLCONV *gdxSymbolAddComment_t) (gdxHandle_t pgdx, int SyNr, const char *Txt);
/** Add a line of comment text for a symbol. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param Txt Explanatory text of the acronym (gdxAcronym...)/String to be registered(gdxAddSetText)/Text found for the entry (gdxGetElemText)/String to add (gdxSymbolAddComment)/String containing requested line(gdxSymbolGetComment)
 */
GDX_FUNCPTR(gdxSymbolAddComment);

typedef int  (GDX_CALLCONV *gdxSymbolGetComment_t) (gdxHandle_t pgdx, int SyNr, int N, char *Txt);
/** Retrieve a line of comment text for a symbol. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param N Index number/Tracing level,  N=<0 no tracing  N>=3 maximum tracing (gdxSetTraceLevel)/Line number (gdxSymbolGetComment)
 * @param Txt Explanatory text of the acronym (gdxAcronym...)/String to be registered(gdxAddSetText)/Text found for the entry (gdxGetElemText)/String to add (gdxSymbolAddComment)/String containing requested line(gdxSymbolGetComment)
 */
GDX_FUNCPTR(gdxSymbolGetComment);

typedef int  (GDX_CALLCONV *gdxSymbolGetDomain_t) (gdxHandle_t pgdx, int SyNr, int DomainSyNrs[]);
/** Retrieve the domain of a symbol. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param DomainSyNrs 
 */
GDX_FUNCPTR(gdxSymbolGetDomain);

typedef int  (GDX_CALLCONV *gdxSymbolGetDomainX_t) (gdxHandle_t pgdx, int SyNr, char *DomainIDs[]);
/** Retrieve the domain of a symbol (Relaxed version). 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param DomainIDs Array containing the set identifiers or * of the domain for the corresponding index position
 */
GDX_FUNCPTR(gdxSymbolGetDomainX);

typedef int  (GDX_CALLCONV *gdxSymbolDim_t) (gdxHandle_t pgdx, int SyNr);
/** Retrieve dimension of a symbol.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 */
GDX_FUNCPTR(gdxSymbolDim);

typedef int  (GDX_CALLCONV *gdxSymbolInfo_t) (gdxHandle_t pgdx, int SyNr, char *SyId, int *Dimen, int *Typ);
/** Returns information about a symbol. 0 if the symbol number is out of range, nonzero otherwise.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param SyId Name of the acronym/symbol; might be an empty string at gdxAcronymName
 * @param Dimen Dimension of the symbol/index space; index space means the number of index positions that is not fixed (gdxDataReadSlice)
 * @param Typ Type of the symbol
 */
GDX_FUNCPTR(gdxSymbolInfo);

typedef int  (GDX_CALLCONV *gdxSymbolInfoX_t) (gdxHandle_t pgdx, int SyNr, int *RecCnt, int *UserInfo, char *ExplTxt);
/** Returns additional information about a symbol. 0 if the symbol number is out of range, nonzero otherwise.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param RecCnt Total number of records stored (unmapped)
 * @param UserInfo Any integer value/User field value (gdxSymbolInfoX)
 * @param ExplTxt Explanatory text for the symbol
 */
GDX_FUNCPTR(gdxSymbolInfoX);

typedef int  (GDX_CALLCONV *gdxSymbolSetDomain_t) (gdxHandle_t pgdx, const char *DomainIDs[]);
/** Define the domain of the symbol for which a write data operation just started using DataWriteRawStart, DataWriteMapStart or DataWriteStrStart. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param DomainIDs Array containing the set identifiers or * of the domain for the corresponding index position
 */
GDX_FUNCPTR(gdxSymbolSetDomain);

typedef int  (GDX_CALLCONV *gdxSymbolSetDomainX_t) (gdxHandle_t pgdx, int SyNr, const char *DomainIDs[]);
/** Define the domain of symbol SyNr (Relaxed version). 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param DomainIDs Array containing the set identifiers or * of the domain for the corresponding index position
 */
GDX_FUNCPTR(gdxSymbolSetDomainX);

typedef int  (GDX_CALLCONV *gdxSystemInfo_t) (gdxHandle_t pgdx, int *SyCnt, int *UelCnt);
/** Returns the number of symbols and unique elements. Always nonzero.
 *
 * @param pgdx gdx object handle
 * @param SyCnt Number of symbols available in the gdx file
 * @param UelCnt Number of unique elements
 */
GDX_FUNCPTR(gdxSystemInfo);

typedef int  (GDX_CALLCONV *gdxUELMaxLength_t) (gdxHandle_t pgdx);
/** Returns the length of the longest UEL name.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxUELMaxLength);

typedef int  (GDX_CALLCONV *gdxUELRegisterDone_t) (gdxHandle_t pgdx);
/** Finish registration of unique elements. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxUELRegisterDone);

typedef int  (GDX_CALLCONV *gdxUELRegisterMap_t) (gdxHandle_t pgdx, int UMap, const char *Uel);
/** Register a unique element in mapped mode. A unique element must follow the GAMS rules when it contains quote characters. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param UMap User index number to be assigned to the unique element, -1 if not found or the element was never mapped
 * @param Uel String for the unique element
 */
GDX_FUNCPTR(gdxUELRegisterMap);

typedef int  (GDX_CALLCONV *gdxUELRegisterMapStart_t) (gdxHandle_t pgdx);
/** Start registering unique elements in mapped mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxUELRegisterMapStart);

typedef int  (GDX_CALLCONV *gdxUELRegisterRaw_t) (gdxHandle_t pgdx, const char *Uel);
/** Register a unique element in raw mode. This can only be used while writing to a gdx file. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param Uel String for the unique element
 */
GDX_FUNCPTR(gdxUELRegisterRaw);

typedef int  (GDX_CALLCONV *gdxUELRegisterRawStart_t) (gdxHandle_t pgdx);
/** Start registering unique elements in raw mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxUELRegisterRawStart);

typedef int  (GDX_CALLCONV *gdxUELRegisterStr_t) (gdxHandle_t pgdx, const char *Uel, int *UelNr);
/** Register a unique element in string mode. A unique element must follow the GAMS rules when it contains quote characters. Nonzero if the element was registered, zero otherwise.
 *
 * @param pgdx gdx object handle
 * @param Uel String for the unique element
 * @param UelNr Internal unique element number or -1 if not found
 */
GDX_FUNCPTR(gdxUELRegisterStr);

typedef int  (GDX_CALLCONV *gdxUELRegisterStrStart_t) (gdxHandle_t pgdx);
/** Start registering unique elements in string mode. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxUELRegisterStrStart);

typedef int  (GDX_CALLCONV *gdxUMFindUEL_t) (gdxHandle_t pgdx, const char *Uel, int *UelNr, int *UelMap);
/** Search for a unique element by its string. Nonzero if the element was found, 0 otherwise.
 *
 * @param pgdx gdx object handle
 * @param Uel String for the unique element
 * @param UelNr Internal unique element number or -1 if not found
 * @param UelMap Unique element number in the user index space or -1 if element was never mapped
 */
GDX_FUNCPTR(gdxUMFindUEL);

typedef int  (GDX_CALLCONV *gdxUMUelGet_t) (gdxHandle_t pgdx, int UelNr, char *Uel, int *UelMap);
/** Get a unique element using an unmapped index. 0 if the operation is not possible.
 *
 * @param pgdx gdx object handle
 * @param UelNr Internal unique element number or -1 if not found
 * @param Uel String for the unique element
 * @param UelMap Unique element number in the user index space or -1 if element was never mapped
 */
GDX_FUNCPTR(gdxUMUelGet);

typedef int  (GDX_CALLCONV *gdxUMUelInfo_t) (gdxHandle_t pgdx, int *UelCnt, int *HighMap);
/** Returns information about the unique elements. Always nonzero.
 *
 * @param pgdx gdx object handle
 * @param UelCnt Number of unique elements
 * @param HighMap 
 */
GDX_FUNCPTR(gdxUMUelInfo);

typedef int  (GDX_CALLCONV *gdxGetDomainElements_t) (gdxHandle_t pgdx, int SyNr, int DimPos, int FilterNr, TDomainIndexProc_t DP, int *NrElem, void *Uptr);
/** Get the unique elements for a given dimension of a given symbol.
 *
 * @param pgdx gdx object handle
 * @param SyNr The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe
 * @param DimPos 
 * @param FilterNr Filter number
 * @param DP Callback procedure that will be called for each item
 * @param NrElem 
 * @param Uptr 
 */
GDX_FUNCPTR(gdxGetDomainElements);

typedef int  (GDX_CALLCONV *gdxCurrentDim_t) (gdxHandle_t pgdx);
/** Returns the dimension of the current active symbol. When reading or writing data, the dimension of the current active symbol is sometimes needed to convert arguments from strings to pchars etc.
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxCurrentDim);

typedef int  (GDX_CALLCONV *gdxRenameUEL_t) (gdxHandle_t pgdx, const char *OldName, const char *NewName);
/** Rename a previously known unique element.
 *
 * @param pgdx gdx object handle
 * @param OldName Name of an existing UEL
 * @param NewName New name of the UEL
 */
GDX_FUNCPTR(gdxRenameUEL);

typedef int  (GDX_CALLCONV *gdxStoreDomainSets_t) (gdxHandle_t pgdx);
/** Flag to store one dimensional sets as potential domains, false saves lots of space for large 1-dim sets that are no domains but can create inconsistent GDX files if used incorrectly'
 *
 * @param pgdx gdx object handle
 */
GDX_FUNCPTR(gdxStoreDomainSets);

typedef void (GDX_CALLCONV *gdxStoreDomainSetsSet_t) (gdxHandle_t pgdx, const int x);
GDX_FUNCPTR(gdxStoreDomainSetsSet);

#if defined(__cplusplus)
}
#endif
#endif /* #if ! defined(_GDXCC_H_) */

