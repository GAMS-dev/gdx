<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GAMS Data eXchange (GDX) API: gdx::TGXFileObj Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">GAMS Data eXchange (GDX) API
   </div>
   <div id="projectbrief">Low-level &quot;eXPert level&quot; C++ API for reading and writing GAMS Data eXchange files</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classgdx_1_1TGXFileObj.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgdx_1_1TGXFileObj-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">gdx::TGXFileObj Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="gdx_8h_source.html">gdx.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3c7cd8bed0ced83650b0224912d0dc2b"><td class="memItemLeft" align="right" valign="top"><a id="a3c7cd8bed0ced83650b0224912d0dc2b" name="a3c7cd8bed0ced83650b0224912d0dc2b"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>TraceLevels</b> { <b>trl_none</b>
, <b>trl_errors</b>
, <b>trl_some</b>
, <b>trl_all</b>
 }</td></tr>
<tr class="separator:a3c7cd8bed0ced83650b0224912d0dc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aed5b4c956fa02b36eb37921fba82f945"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aed5b4c956fa02b36eb37921fba82f945">TGXFileObj</a> (std::string &amp;ErrMsg)</td></tr>
<tr class="memdesc:aed5b4c956fa02b36eb37921fba82f945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new GDX file object. Does not open a file yet.  <a href="classgdx_1_1TGXFileObj.html#aed5b4c956fa02b36eb37921fba82f945">More...</a><br /></td></tr>
<tr class="separator:aed5b4c956fa02b36eb37921fba82f945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0b322387deb11ac80960bfa27684a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ace0b322387deb11ac80960bfa27684a5">~TGXFileObj</a> ()</td></tr>
<tr class="memdesc:ace0b322387deb11ac80960bfa27684a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose GDX file object.  <a href="classgdx_1_1TGXFileObj.html#ace0b322387deb11ac80960bfa27684a5">More...</a><br /></td></tr>
<tr class="separator:ace0b322387deb11ac80960bfa27684a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112bd6898cabcb291e0f0d23a1f56659"><td class="memItemLeft" align="right" valign="top"><a id="a112bd6898cabcb291e0f0d23a1f56659" name="a112bd6898cabcb291e0f0d23a1f56659"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetTraceLevel</b> (TraceLevels tl)</td></tr>
<tr class="separator:a112bd6898cabcb291e0f0d23a1f56659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5290760aefaf9af4ab092d68fd187642"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a5290760aefaf9af4ab092d68fd187642">gdxStoreDomainSets</a> () const</td></tr>
<tr class="memdesc:a5290760aefaf9af4ab092d68fd187642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flag to store one dimensional sets as potential domains, false (0) saves lots of space for large 1-dim sets that are no domains but can create inconsistent GDX files if used incorrectly. Returns 1 (true) iff. elements of 1-dim sets should be tracked for domain checking, 0 (false) otherwise.  <a href="classgdx_1_1TGXFileObj.html#a5290760aefaf9af4ab092d68fd187642">More...</a><br /></td></tr>
<tr class="separator:a5290760aefaf9af4ab092d68fd187642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa88feb1bb15e035596dbb87e630f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a5aa88feb1bb15e035596dbb87e630f0c">gdxStoreDomainSetsSet</a> (int flag)</td></tr>
<tr class="memdesc:a5aa88feb1bb15e035596dbb87e630f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flag to store one dimensional sets as potential domains, false (0) saves lots of space for large 1-dim sets that are no domains but can create inconsistent GDX files if used incorrectly. Param flag 1 (true) iff. elements of 1-dim sets should be tracked for domain checking, 0 (false) otherwise.  <a href="classgdx_1_1TGXFileObj.html#a5aa88feb1bb15e035596dbb87e630f0c">More...</a><br /></td></tr>
<tr class="separator:a5aa88feb1bb15e035596dbb87e630f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbb4eac89440b34955ec4bdd97a3147"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a8dbb4eac89440b34955ec4bdd97a3147">gdxAllowBogusDomains</a> () const</td></tr>
<tr class="memdesc:a8dbb4eac89440b34955ec4bdd97a3147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flag to ignore using 1-dim sets as domain when their elements are not tracked (see gdxStoreDomainSets). In case the flag is enabled this is allowing potentially unsafe writing of records to symbols with one dimensional sets as domain, when GDX has no lookup table for the elements of this set. This can happen when <code>gdxStoreDomainSets</code> was disabled by the user to save memory. For backwards compatability, this is enabled by default. Return 1 (true) iff. using a 1-dim set as domain (when store domain sets option is disabled) should be ignored. Otherwise an error is raised (ERR_NODOMAINDATA).  <a href="classgdx_1_1TGXFileObj.html#a8dbb4eac89440b34955ec4bdd97a3147">More...</a><br /></td></tr>
<tr class="separator:a8dbb4eac89440b34955ec4bdd97a3147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6f2da3823e3f3ac38cb7cd5ec1e376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#acb6f2da3823e3f3ac38cb7cd5ec1e376">gdxAllowBogusDomainsSet</a> (int flag)</td></tr>
<tr class="memdesc:acb6f2da3823e3f3ac38cb7cd5ec1e376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flag to ignore using 1-dim sets as domain when their elements are not tracked (see gdxStoreDomainSets). Toggle allowing potentially unsafe writing of records to symbols with one dimensional sets as domain, when GDX has no lookup table for the elements of this set. This can happen when <code>gdxStoreDomainSets</code> was disabled by the user to save memory. For backwards compatability, this is enabled by default. When the user explicitly disables it, e.g. via <code>gdxAllowBogusDomainsSet(false)</code>, then using a one dimensional set as domain will cause a GDX error (ERR_NODOMAINDATA). Param flag 1 (true) iff. using a 1-dim set as domain (when store domain sets option is disabled) should be ignored. Otherwise an error is raised (ERR_NODOMAINDATA).  <a href="classgdx_1_1TGXFileObj.html#acb6f2da3823e3f3ac38cb7cd5ec1e376">More...</a><br /></td></tr>
<tr class="separator:acb6f2da3823e3f3ac38cb7cd5ec1e376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a8f3d3aa5d41615ecb4e41d64c9669"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a22a8f3d3aa5d41615ecb4e41d64c9669">gdxMapAcronymsToNaN</a> () const</td></tr>
<tr class="memdesc:a22a8f3d3aa5d41615ecb4e41d64c9669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to map all acronym values to the GAMS "Not a Number" special value. Disabled by default.  <a href="classgdx_1_1TGXFileObj.html#a22a8f3d3aa5d41615ecb4e41d64c9669">More...</a><br /></td></tr>
<tr class="separator:a22a8f3d3aa5d41615ecb4e41d64c9669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d766eb279da81358bba0496a1dc35f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#af2d766eb279da81358bba0496a1dc35f">gdxMapAcronymsToNaNSet</a> (int flag)</td></tr>
<tr class="memdesc:af2d766eb279da81358bba0496a1dc35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to map all acronym values to the GAMS "Not a Number" special value. Disabled by default.  <a href="classgdx_1_1TGXFileObj.html#af2d766eb279da81358bba0496a1dc35f">More...</a><br /></td></tr>
<tr class="separator:af2d766eb279da81358bba0496a1dc35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38540e57b8b2b29a0f37a7842bf5706"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ac38540e57b8b2b29a0f37a7842bf5706">gdxAddAlias</a> (const char *Id1, const char *Id2)</td></tr>
<tr class="memdesc:ac38540e57b8b2b29a0f37a7842bf5706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alias for a set to the symbol table. One of the two identifiers has to be a known set, an alias or "*" (universe); the other identifier is used as the new alias for the given set. The function gdxSymbolInfoX can be used to retrieve the set or alias associated with the identifier; it is returned as the UserInfo parameter.  <a href="classgdx_1_1TGXFileObj.html#ac38540e57b8b2b29a0f37a7842bf5706">More...</a><br /></td></tr>
<tr class="separator:ac38540e57b8b2b29a0f37a7842bf5706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b2458fa7062edde0eedde8fc5ec40a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ae0b2458fa7062edde0eedde8fc5ec40a">gdxAutoConvert</a> (int NV)</td></tr>
<tr class="memdesc:ae0b2458fa7062edde0eedde8fc5ec40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the AutoConvert variable and sets the variable to nv. When we close a new GDX file, we look at the value of AutoConvert; if AutoConvert is non-zero, we look at the GDXCOMPRESS and GDXCONVERT environment variables to determine if conversion to an older file format is desired. We needed this logic so gdxcopy.exe can disable automatic file conversion.  <a href="classgdx_1_1TGXFileObj.html#ae0b2458fa7062edde0eedde8fc5ec40a">More...</a><br /></td></tr>
<tr class="separator:ae0b2458fa7062edde0eedde8fc5ec40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a18dada36a25f6ea5391d5b263bc173"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a2a18dada36a25f6ea5391d5b263bc173">gdxGetMemoryUsed</a> ()</td></tr>
<tr class="memdesc:a2a18dada36a25f6ea5391d5b263bc173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes used by the data objects.  <a href="classgdx_1_1TGXFileObj.html#a2a18dada36a25f6ea5391d5b263bc173">More...</a><br /></td></tr>
<tr class="separator:a2a18dada36a25f6ea5391d5b263bc173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Acronyms</div></td></tr>
<tr class="memitem:aa82277b5095243030de46f35491e3cb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aa82277b5095243030de46f35491e3cb8">gdxAcronymAdd</a> (const char *AName, const char *Txt, int AIndx)</td></tr>
<tr class="memdesc:aa82277b5095243030de46f35491e3cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new acronym entry. This can be used to add entries before data is written. Returns negative value (&lt;0) if the entry is not added.  <a href="classgdx_1_1TGXFileObj.html#aa82277b5095243030de46f35491e3cb8">More...</a><br /></td></tr>
<tr class="separator:aa82277b5095243030de46f35491e3cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80a7c83abf48f228ffb66dd136d373b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ad80a7c83abf48f228ffb66dd136d373b">gdxAcronymCount</a> () const</td></tr>
<tr class="memdesc:ad80a7c83abf48f228ffb66dd136d373b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries in the acronym table.  <a href="classgdx_1_1TGXFileObj.html#ad80a7c83abf48f228ffb66dd136d373b">More...</a><br /></td></tr>
<tr class="separator:ad80a7c83abf48f228ffb66dd136d373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0593d8da6fedf8237126611eae81485e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a0593d8da6fedf8237126611eae81485e">gdxAcronymGetInfo</a> (int N, char *AName, char *Txt, int &amp;AIndx) const</td></tr>
<tr class="memdesc:a0593d8da6fedf8237126611eae81485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve acronym information from the acronym table. Non-zero if the index into the acronym table is valid.  <a href="classgdx_1_1TGXFileObj.html#a0593d8da6fedf8237126611eae81485e">More...</a><br /></td></tr>
<tr class="separator:a0593d8da6fedf8237126611eae81485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc7c9a9290a8e60df48638b48e625c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#adcc7c9a9290a8e60df48638b48e625c7">gdxAcronymGetMapping</a> (int N, int &amp;orgIndx, int &amp;newIndx, int &amp;autoIndex)</td></tr>
<tr class="memdesc:adcc7c9a9290a8e60df48638b48e625c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information how acronym values are remapped. When reading GDX data, we need to map indices for acronyms used in the GDX file to indices used by the reading program. Non-zero if the index into the acronym table is valid.  <a href="classgdx_1_1TGXFileObj.html#adcc7c9a9290a8e60df48638b48e625c7">More...</a><br /></td></tr>
<tr class="separator:adcc7c9a9290a8e60df48638b48e625c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1979f01dacdbb2e2e0309d21fc778db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aa1979f01dacdbb2e2e0309d21fc778db">gdxAcronymIndex</a> (double V) const</td></tr>
<tr class="memdesc:aa1979f01dacdbb2e2e0309d21fc778db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index value of an acronym. Returns zero if V does not represent an acronym.  <a href="classgdx_1_1TGXFileObj.html#aa1979f01dacdbb2e2e0309d21fc778db">More...</a><br /></td></tr>
<tr class="separator:aa1979f01dacdbb2e2e0309d21fc778db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f71f613be88ee5af372289aa4db2342"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a6f71f613be88ee5af372289aa4db2342">gdxAcronymName</a> (double V, char *AName)</td></tr>
<tr class="memdesc:a6f71f613be88ee5af372289aa4db2342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the name of an acronym value. Non-zero if a name for the acronym is defined. An unnamed acronym value will return a string of the form UnknownAcronymNNN, were NNN is the index of the acronym.  <a href="classgdx_1_1TGXFileObj.html#a6f71f613be88ee5af372289aa4db2342">More...</a><br /></td></tr>
<tr class="separator:a6f71f613be88ee5af372289aa4db2342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc4c0e20c355cc8a91a65727e841d4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a7cc4c0e20c355cc8a91a65727e841d4d">gdxAcronymNextNr</a> (int NV)</td></tr>
<tr class="memdesc:a7cc4c0e20c355cc8a91a65727e841d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the NextAutoAcronym variable and sets the variable to nv.  <a href="classgdx_1_1TGXFileObj.html#a7cc4c0e20c355cc8a91a65727e841d4d">More...</a><br /></td></tr>
<tr class="separator:a7cc4c0e20c355cc8a91a65727e841d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7f6c210e407402fcb24ba63d4392a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#afe7f6c210e407402fcb24ba63d4392a8">gdxAcronymSetInfo</a> (int N, const char *AName, const char *Txt, int AIndx)</td></tr>
<tr class="memdesc:afe7f6c210e407402fcb24ba63d4392a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify acronym information in the acronym table.  <a href="classgdx_1_1TGXFileObj.html#afe7f6c210e407402fcb24ba63d4392a8">More...</a><br /></td></tr>
<tr class="separator:afe7f6c210e407402fcb24ba63d4392a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3171c1f888a68e2edf729e35da916f03"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a3171c1f888a68e2edf729e35da916f03">gdxAcronymValue</a> (int AIndx) const</td></tr>
<tr class="memdesc:a3171c1f888a68e2edf729e35da916f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an acronym value based on the index (AIndx should be greater than 0). Returns the calculated acronym value (zero if AIndx is &lt;0).  <a href="classgdx_1_1TGXFileObj.html#a3171c1f888a68e2edf729e35da916f03">More...</a><br /></td></tr>
<tr class="separator:a3171c1f888a68e2edf729e35da916f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comment</div></td></tr>
<tr class="memitem:a0473b4f834a31d23e494ae5b1323f380"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a0473b4f834a31d23e494ae5b1323f380">gdxSymbolAddComment</a> (int SyNr, const char *Txt)</td></tr>
<tr class="memdesc:a0473b4f834a31d23e494ae5b1323f380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a line of comment text for a symbol. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a0473b4f834a31d23e494ae5b1323f380">More...</a><br /></td></tr>
<tr class="separator:a0473b4f834a31d23e494ae5b1323f380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbad43f6b67e6858a2fc2af9b9b7101"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a0cbad43f6b67e6858a2fc2af9b9b7101">gdxSymbolGetComment</a> (int SyNr, int N, char *Txt)</td></tr>
<tr class="memdesc:a0cbad43f6b67e6858a2fc2af9b9b7101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a line of comment text for a symbol. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a0cbad43f6b67e6858a2fc2af9b9b7101">More...</a><br /></td></tr>
<tr class="separator:a0cbad43f6b67e6858a2fc2af9b9b7101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Domain</div></td></tr>
<tr class="memitem:acf107aae2a6daf07c721f1a2ce8e70a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#acf107aae2a6daf07c721f1a2ce8e70a5">gdxSymbolGetDomain</a> (int SyNr, int *DomainSyNrs)</td></tr>
<tr class="memdesc:acf107aae2a6daf07c721f1a2ce8e70a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the domain of a symbol. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#acf107aae2a6daf07c721f1a2ce8e70a5">More...</a><br /></td></tr>
<tr class="separator:acf107aae2a6daf07c721f1a2ce8e70a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b75bb5610c7bb4c710b0c312074edeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a2b75bb5610c7bb4c710b0c312074edeb">gdxSymbolGetDomainX</a> (int SyNr, char **DomainIDs)</td></tr>
<tr class="memdesc:a2b75bb5610c7bb4c710b0c312074edeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the domain of a symbol (using relaxed or domain information). Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a2b75bb5610c7bb4c710b0c312074edeb">More...</a><br /></td></tr>
<tr class="separator:a2b75bb5610c7bb4c710b0c312074edeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3955eaf00687760c2b7cdce9c9eb9fd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a3955eaf00687760c2b7cdce9c9eb9fd7">gdxSymbolSetDomain</a> (const char **DomainIDs)</td></tr>
<tr class="memdesc:a3955eaf00687760c2b7cdce9c9eb9fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the domain of a symbol for which a write data operation just started using DataWriteRawStart, DataWriteMapStart or DataWriteStrStart. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a3955eaf00687760c2b7cdce9c9eb9fd7">More...</a><br /></td></tr>
<tr class="separator:a3955eaf00687760c2b7cdce9c9eb9fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39687019d377ad28428f052d49672ac1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a39687019d377ad28428f052d49672ac1">gdxSymbolSetDomainX</a> (int SyNr, const char **DomainIDs)</td></tr>
<tr class="memdesc:a39687019d377ad28428f052d49672ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the domain of a symbol (relaxed version). Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a39687019d377ad28428f052d49672ac1">More...</a><br /></td></tr>
<tr class="separator:a39687019d377ad28428f052d49672ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fec2813995c0fa49b83a0838faf4ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a44fec2813995c0fa49b83a0838faf4ff">gdxGetDomainElements</a> (int SyNr, int DimPos, int FilterNr, TDomainIndexProc_t DP, int &amp;NrElem, void *Uptr)</td></tr>
<tr class="memdesc:a44fec2813995c0fa49b83a0838faf4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique elements for a given dimension of a given symbol.  <a href="classgdx_1_1TGXFileObj.html#a44fec2813995c0fa49b83a0838faf4ff">More...</a><br /></td></tr>
<tr class="separator:a44fec2813995c0fa49b83a0838faf4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File (Open/Close)</div></td></tr>
<tr class="memitem:a871263601526037bc936b71389813e0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a871263601526037bc936b71389813e0b">gdxClose</a> ()</td></tr>
<tr class="memdesc:a871263601526037bc936b71389813e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a GDX file that was previously opened for reading or writing. Before the file is closed, any pending write operations will be finished. This does not free the GDX in-memory object. This method will automatically be called when the GDX object lifetime ends (e.g. being out of scope).  <a href="classgdx_1_1TGXFileObj.html#a871263601526037bc936b71389813e0b">More...</a><br /></td></tr>
<tr class="separator:a871263601526037bc936b71389813e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f09635e83e11b65dcfdcbd617f0600"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a52f09635e83e11b65dcfdcbd617f0600">gdxOpenAppend</a> (const char *FileName, const char *Producer, int &amp;ErrNr)</td></tr>
<tr class="memdesc:a52f09635e83e11b65dcfdcbd617f0600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an existing GDX file for output. Non-zero if the file can be opened, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#a52f09635e83e11b65dcfdcbd617f0600">More...</a><br /></td></tr>
<tr class="separator:a52f09635e83e11b65dcfdcbd617f0600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3b3e0ffdf3bbb17070e43ba7e98408"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a4a3b3e0ffdf3bbb17070e43ba7e98408">gdxOpenRead</a> (const char *FileName, int &amp;ErrNr)</td></tr>
<tr class="memdesc:a4a3b3e0ffdf3bbb17070e43ba7e98408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a GDX file for reading. Non-zero if the file can be opened, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#a4a3b3e0ffdf3bbb17070e43ba7e98408">More...</a><br /></td></tr>
<tr class="separator:a4a3b3e0ffdf3bbb17070e43ba7e98408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a68a1f9f4bed4dcf87ec54b9938f6e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a0a68a1f9f4bed4dcf87ec54b9938f6e2">gdxOpenReadEx</a> (const char *FileName, int ReadMode, int &amp;ErrNr)</td></tr>
<tr class="memdesc:a0a68a1f9f4bed4dcf87ec54b9938f6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a GDX file for reading allowing for skipping sections. Non-zero if the file can be opened, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#a0a68a1f9f4bed4dcf87ec54b9938f6e2">More...</a><br /></td></tr>
<tr class="separator:a0a68a1f9f4bed4dcf87ec54b9938f6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53f311244734378f4de7c9c7eafdf67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ae53f311244734378f4de7c9c7eafdf67">gdxOpenWrite</a> (const char *FileName, const char *Producer, int &amp;ErrNr)</td></tr>
<tr class="memdesc:ae53f311244734378f4de7c9c7eafdf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a new GDX file for output. Non-zero if the file can be opened, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#ae53f311244734378f4de7c9c7eafdf67">More...</a><br /></td></tr>
<tr class="separator:ae53f311244734378f4de7c9c7eafdf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1538da866ff406cc50477f6bcdc63c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a3a1538da866ff406cc50477f6bcdc63c">gdxOpenWriteEx</a> (const char *FileName, const char *Producer, int Compr, int &amp;ErrNr)</td></tr>
<tr class="memdesc:a3a1538da866ff406cc50477f6bcdc63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a GDX file for writing with explicitly given compression flag. Non-zero if the file can be opened, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#a3a1538da866ff406cc50477f6bcdc63c">More...</a><br /></td></tr>
<tr class="separator:a3a1538da866ff406cc50477f6bcdc63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Filters</div></td></tr>
<tr class="memitem:aba34d285a642dcc849a40ec08846b714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aba34d285a642dcc849a40ec08846b714">gdxFilterExists</a> (int FilterNr)</td></tr>
<tr class="memdesc:aba34d285a642dcc849a40ec08846b714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is a filter defined based on its number as used in gdxFilterRegisterStart. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#aba34d285a642dcc849a40ec08846b714">More...</a><br /></td></tr>
<tr class="separator:aba34d285a642dcc849a40ec08846b714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16fefc5481c2fb90b9632e463376404"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aa16fefc5481c2fb90b9632e463376404">gdxFilterRegister</a> (int UelMap)</td></tr>
<tr class="memdesc:aa16fefc5481c2fb90b9632e463376404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a unique element to the current filter definition, zero if the index number is out of range or was never mapped into the user index space.  <a href="classgdx_1_1TGXFileObj.html#aa16fefc5481c2fb90b9632e463376404">More...</a><br /></td></tr>
<tr class="separator:aa16fefc5481c2fb90b9632e463376404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a6c8f8d316d535ae7257bad7134e06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ab4a6c8f8d316d535ae7257bad7134e06">gdxFilterRegisterDone</a> ()</td></tr>
<tr class="memdesc:ab4a6c8f8d316d535ae7257bad7134e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish registration of unique elements for a filter. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#ab4a6c8f8d316d535ae7257bad7134e06">More...</a><br /></td></tr>
<tr class="separator:ab4a6c8f8d316d535ae7257bad7134e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dfa9d52a679851a308d58636e836b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a26dfa9d52a679851a308d58636e836b4">gdxFilterRegisterStart</a> (int FilterNr)</td></tr>
<tr class="memdesc:a26dfa9d52a679851a308d58636e836b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a unique element filter. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a26dfa9d52a679851a308d58636e836b4">More...</a><br /></td></tr>
<tr class="separator:a26dfa9d52a679851a308d58636e836b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information</div></td></tr>
<tr class="memitem:abf4156f064b906dbf1052d39ceb2f6b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#abf4156f064b906dbf1052d39ceb2f6b9">gdxFindSymbol</a> (const char *SyId, int &amp;SyNr)</td></tr>
<tr class="memdesc:abf4156f064b906dbf1052d39ceb2f6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a symbol by name in the symbol table; the search is not case-sensitive.  <a href="classgdx_1_1TGXFileObj.html#abf4156f064b906dbf1052d39ceb2f6b9">More...</a><br /></td></tr>
<tr class="separator:abf4156f064b906dbf1052d39ceb2f6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4928e7d18a0365c3c0af5aa7f0c65a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ace4928e7d18a0365c3c0af5aa7f0c65a">gdxGetUEL</a> (int UelNr, char *Uel) const</td></tr>
<tr class="memdesc:ace4928e7d18a0365c3c0af5aa7f0c65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string for a unique element using a mapped index. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#ace4928e7d18a0365c3c0af5aa7f0c65a">More...</a><br /></td></tr>
<tr class="separator:ace4928e7d18a0365c3c0af5aa7f0c65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Longest symbol UEL</div></td></tr>
<tr class="memitem:af7de4b7f90ec26e71c54b6e1df1e8595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#af7de4b7f90ec26e71c54b6e1df1e8595">gdxSymbIndxMaxLength</a> (int SyNr, int *LengthInfo)</td></tr>
<tr class="memdesc:af7de4b7f90ec26e71c54b6e1df1e8595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the longest UEL used for every index position for a given symbol.  <a href="classgdx_1_1TGXFileObj.html#af7de4b7f90ec26e71c54b6e1df1e8595">More...</a><br /></td></tr>
<tr class="separator:af7de4b7f90ec26e71c54b6e1df1e8595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ffa7df3ce6a691bc0c41737a012262"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ab2ffa7df3ce6a691bc0c41737a012262">gdxSymbMaxLength</a> () const</td></tr>
<tr class="memdesc:ab2ffa7df3ce6a691bc0c41737a012262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the longest symbol name in the GDX file.  <a href="classgdx_1_1TGXFileObj.html#ab2ffa7df3ce6a691bc0c41737a012262">More...</a><br /></td></tr>
<tr class="separator:ab2ffa7df3ce6a691bc0c41737a012262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d3826003c3392656f5fff96140a6db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a63d3826003c3392656f5fff96140a6db">gdxUELMaxLength</a> () const</td></tr>
<tr class="memdesc:a63d3826003c3392656f5fff96140a6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the longest unique element (UEL) name.  <a href="classgdx_1_1TGXFileObj.html#a63d3826003c3392656f5fff96140a6db">More...</a><br /></td></tr>
<tr class="separator:a63d3826003c3392656f5fff96140a6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Read Data</div></td></tr>
<tr class="memitem:aaae21ed2293db76cdbd05dd06a94a775"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aaae21ed2293db76cdbd05dd06a94a775">gdxDataErrorCount</a> () const</td></tr>
<tr class="memdesc:aaae21ed2293db76cdbd05dd06a94a775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of error records.  <a href="classgdx_1_1TGXFileObj.html#aaae21ed2293db76cdbd05dd06a94a775">More...</a><br /></td></tr>
<tr class="separator:aaae21ed2293db76cdbd05dd06a94a775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c5e9b87188458bfca1d08e4595f4d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a36c5e9b87188458bfca1d08e4595f4d7">gdxDataErrorRecord</a> (int RecNr, int *KeyInt, double *Values)</td></tr>
<tr class="memdesc:a36c5e9b87188458bfca1d08e4595f4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an error record. Non-zero if the record number is valid.  <a href="classgdx_1_1TGXFileObj.html#a36c5e9b87188458bfca1d08e4595f4d7">More...</a><br /></td></tr>
<tr class="separator:a36c5e9b87188458bfca1d08e4595f4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddc3f2a9c1bdf0fe2f947350755d8e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a6ddc3f2a9c1bdf0fe2f947350755d8e4">gdxDataErrorRecordX</a> (int RecNr, int *KeyInt, double *Values)</td></tr>
<tr class="memdesc:a6ddc3f2a9c1bdf0fe2f947350755d8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an error record. Non-zero if the record number is valid.  <a href="classgdx_1_1TGXFileObj.html#a6ddc3f2a9c1bdf0fe2f947350755d8e4">More...</a><br /></td></tr>
<tr class="separator:a6ddc3f2a9c1bdf0fe2f947350755d8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b5065af58cecb5ae945069a9d62a7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c">gdxDataReadDone</a> ()</td></tr>
<tr class="memdesc:a99b5065af58cecb5ae945069a9d62a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c">More...</a><br /></td></tr>
<tr class="separator:a99b5065af58cecb5ae945069a9d62a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9314cf277f2e61c7f3c2301cdfe54f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a0c9314cf277f2e61c7f3c2301cdfe54f">gdxDataReadFilteredStart</a> (int SyNr, const int *FilterAction, int &amp;NrRecs)</td></tr>
<tr class="memdesc:a0c9314cf277f2e61c7f3c2301cdfe54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the reading of a symbol in filtered mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a0c9314cf277f2e61c7f3c2301cdfe54f">More...</a><br /></td></tr>
<tr class="separator:a0c9314cf277f2e61c7f3c2301cdfe54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4009a92eba081f08a7f8ccaed7856e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ab4009a92eba081f08a7f8ccaed7856e8">gdxDataReadMap</a> (int RecNr, int *KeyInt, double *Values, int &amp;DimFrst)</td></tr>
<tr class="memdesc:ab4009a92eba081f08a7f8ccaed7856e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next record in mapped mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#ab4009a92eba081f08a7f8ccaed7856e8">More...</a><br /></td></tr>
<tr class="separator:ab4009a92eba081f08a7f8ccaed7856e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e98f4facd1e175c214e45e31172e54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a83e98f4facd1e175c214e45e31172e54">gdxDataReadMapStart</a> (int SyNr, int &amp;NrRecs)</td></tr>
<tr class="memdesc:a83e98f4facd1e175c214e45e31172e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the reading of a symbol in mapped mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a83e98f4facd1e175c214e45e31172e54">More...</a><br /></td></tr>
<tr class="separator:a83e98f4facd1e175c214e45e31172e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81311547743068a58c162e4fdbf7b063"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a81311547743068a58c162e4fdbf7b063">gdxDataReadRaw</a> (int *KeyInt, double *Values, int &amp;DimFrst)</td></tr>
<tr class="memdesc:a81311547743068a58c162e4fdbf7b063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next record in raw mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a81311547743068a58c162e4fdbf7b063">More...</a><br /></td></tr>
<tr class="separator:a81311547743068a58c162e4fdbf7b063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e7d780747818f4fc7deaf0e6e71f0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a34e7d780747818f4fc7deaf0e6e71f0c">gdxDataReadRawFast</a> (int SyNr, TDataStoreProc_t DP, int &amp;NrRecs)</td></tr>
<tr class="memdesc:a34e7d780747818f4fc7deaf0e6e71f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a symbol in Raw mode using a callback procedure. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a34e7d780747818f4fc7deaf0e6e71f0c">More...</a><br /></td></tr>
<tr class="separator:a34e7d780747818f4fc7deaf0e6e71f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb5de98a6e194622ac0685f8c3fdbc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#abeb5de98a6e194622ac0685f8c3fdbc9">gdxDataReadRawFastEx</a> (int SyNr, TDataStoreExProc_t DP, int &amp;NrRecs, void *Uptr)</td></tr>
<tr class="memdesc:abeb5de98a6e194622ac0685f8c3fdbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a symbol in Raw mode using a callback procedure. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#abeb5de98a6e194622ac0685f8c3fdbc9">More...</a><br /></td></tr>
<tr class="separator:abeb5de98a6e194622ac0685f8c3fdbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014bf6aef956e6fbc0536e40c0cfb42f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a014bf6aef956e6fbc0536e40c0cfb42f">gdxDataReadRawFastFilt</a> (int SyNr, const char **UelFilterStr, TDataStoreFiltProc_t DP)</td></tr>
<tr class="memdesc:a014bf6aef956e6fbc0536e40c0cfb42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a symbol in Raw mode while applying a filter using a callback procedure. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a014bf6aef956e6fbc0536e40c0cfb42f">More...</a><br /></td></tr>
<tr class="separator:a014bf6aef956e6fbc0536e40c0cfb42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895ee00426e6ec788879d394d484dad9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a895ee00426e6ec788879d394d484dad9">gdxDataReadRawStart</a> (int SyNr, int &amp;NrRecs)</td></tr>
<tr class="memdesc:a895ee00426e6ec788879d394d484dad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the reading of a symbol in raw mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a895ee00426e6ec788879d394d484dad9">More...</a><br /></td></tr>
<tr class="separator:a895ee00426e6ec788879d394d484dad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8990e8e89f522a1e1eee79e6ea49fbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aa8990e8e89f522a1e1eee79e6ea49fbf">gdxDataReadSlice</a> (const char **UelFilterStr, int &amp;Dimen, TDataStoreProc_t DP)</td></tr>
<tr class="memdesc:aa8990e8e89f522a1e1eee79e6ea49fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a slice of data from a data set, by fixing zero or more index positions in the data. When a data element is available, the callback procedure DP is called with the current index and the values. The indices used in the index vary from zero to the highest value minus one for that index position. This function can be called multiple times. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#aa8990e8e89f522a1e1eee79e6ea49fbf">More...</a><br /></td></tr>
<tr class="separator:aa8990e8e89f522a1e1eee79e6ea49fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762d113f3c6f11a268a18d46b0981220"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a762d113f3c6f11a268a18d46b0981220">gdxDataReadSliceStart</a> (int SyNr, int *ElemCounts)</td></tr>
<tr class="memdesc:a762d113f3c6f11a268a18d46b0981220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare for the reading of a slice of data from a data set. The actual read of the data is done by calling gdxDataReadSlice. When finished reading, call gdxDataReadDone. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a762d113f3c6f11a268a18d46b0981220">More...</a><br /></td></tr>
<tr class="separator:a762d113f3c6f11a268a18d46b0981220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0ab73d8dee5f9e499e1bd7ce5f9ce1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a7f0ab73d8dee5f9e499e1bd7ce5f9ce1">gdxDataReadStr</a> (char **KeyStr, double *Values, int &amp;DimFrst)</td></tr>
<tr class="memdesc:a7f0ab73d8dee5f9e499e1bd7ce5f9ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next record using strings for the unique elements. The reading should be initialized by calling DataReadStrStart. Returns zero if the operation is not possible or if there is no more data.  <a href="classgdx_1_1TGXFileObj.html#a7f0ab73d8dee5f9e499e1bd7ce5f9ce1">More...</a><br /></td></tr>
<tr class="separator:a7f0ab73d8dee5f9e499e1bd7ce5f9ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3db6bbe6a4820809df84c38387735a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aed3db6bbe6a4820809df84c38387735a">gdxDataReadStrStart</a> (int SyNr, int &amp;NrRecs)</td></tr>
<tr class="memdesc:aed3db6bbe6a4820809df84c38387735a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the reading of a symbol in string mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#aed3db6bbe6a4820809df84c38387735a">More...</a><br /></td></tr>
<tr class="separator:aed3db6bbe6a4820809df84c38387735a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86835775ac2e5124e883d1f4e2678582"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a86835775ac2e5124e883d1f4e2678582">gdxDataSliceUELS</a> (const int *SliceKeyInt, char **KeyStr)</td></tr>
<tr class="memdesc:a86835775ac2e5124e883d1f4e2678582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a slice index in to the corresponding unique elements. After calling DataReadSliceStart, each index position is mapped from 0 to N(d)-1. This function maps this index space back in to unique elements represented as strings. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a86835775ac2e5124e883d1f4e2678582">More...</a><br /></td></tr>
<tr class="separator:a86835775ac2e5124e883d1f4e2678582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Special values</div></td></tr>
<tr class="memitem:ac3eee784b7fe5b800699a510eadc9ce5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ac3eee784b7fe5b800699a510eadc9ce5">gdxGetSpecialValues</a> (double *AVals)</td></tr>
<tr class="memdesc:ac3eee784b7fe5b800699a510eadc9ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the internal values for special values. Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#ac3eee784b7fe5b800699a510eadc9ce5">More...</a><br /></td></tr>
<tr class="separator:ac3eee784b7fe5b800699a510eadc9ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4316f65e6f0c68c3ca6f0a32671ea823"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a4316f65e6f0c68c3ca6f0a32671ea823">gdxMapValue</a> (double D, int &amp;sv)</td></tr>
<tr class="memdesc:a4316f65e6f0c68c3ca6f0a32671ea823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classify a value as a potential special value. Non-zero if D is a special value, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#a4316f65e6f0c68c3ca6f0a32671ea823">More...</a><br /></td></tr>
<tr class="separator:a4316f65e6f0c68c3ca6f0a32671ea823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d37f601cb0b974081d0ca4c899c0f7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a6d37f601cb0b974081d0ca4c899c0f7f">gdxResetSpecialValues</a> ()</td></tr>
<tr class="memdesc:a6d37f601cb0b974081d0ca4c899c0f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal values for special values. Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#a6d37f601cb0b974081d0ca4c899c0f7f">More...</a><br /></td></tr>
<tr class="separator:a6d37f601cb0b974081d0ca4c899c0f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01fdf317cb96c6a94a3e53bd3b052ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ac01fdf317cb96c6a94a3e53bd3b052ff">gdxSetReadSpecialValues</a> (const double *AVals)</td></tr>
<tr class="memdesc:ac01fdf317cb96c6a94a3e53bd3b052ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal values for special values when reading a GDX file. Before calling this function, initialize the array of special values by calling gdxGetSpecialValues first. Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#ac01fdf317cb96c6a94a3e53bd3b052ff">More...</a><br /></td></tr>
<tr class="separator:ac01fdf317cb96c6a94a3e53bd3b052ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2598f7b7a88909edb367ae931dbda1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aaa2598f7b7a88909edb367ae931dbda1">gdxSetSpecialValues</a> (const double *AVals)</td></tr>
<tr class="memdesc:aaa2598f7b7a88909edb367ae931dbda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal values for special values. Before calling this function, initialize the array of special values by calling gdxGetSpecialValues first. Note, values in AVals have to be unique. Non- zero if all values specified are unique, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#aaa2598f7b7a88909edb367ae931dbda1">More...</a><br /></td></tr>
<tr class="separator:aaa2598f7b7a88909edb367ae931dbda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">System/Symbol</div></td></tr>
<tr class="memitem:aed2e8aa58d63ae1d7b7f89b517280355"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aed2e8aa58d63ae1d7b7f89b517280355">gdxFileInfo</a> (int &amp;FileVer, int &amp;ComprLev) const</td></tr>
<tr class="memdesc:aed2e8aa58d63ae1d7b7f89b517280355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns file format number and compression level used. Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#aed2e8aa58d63ae1d7b7f89b517280355">More...</a><br /></td></tr>
<tr class="separator:aed2e8aa58d63ae1d7b7f89b517280355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734edcd65d93902112d4bed17ae00edd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a734edcd65d93902112d4bed17ae00edd">gdxSymbolDim</a> (int SyNr)</td></tr>
<tr class="memdesc:a734edcd65d93902112d4bed17ae00edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns dimensionality of a symbol.  <a href="classgdx_1_1TGXFileObj.html#a734edcd65d93902112d4bed17ae00edd">More...</a><br /></td></tr>
<tr class="separator:a734edcd65d93902112d4bed17ae00edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6f6ffff7ed12a048c8d4afcbe106fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a8f6f6ffff7ed12a048c8d4afcbe106fd">gdxSymbolInfo</a> (int SyNr, char *SyId, int &amp;Dimen, int &amp;Typ)</td></tr>
<tr class="memdesc:a8f6f6ffff7ed12a048c8d4afcbe106fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information (name, dimension count, type) about a symbol from the symbol table. Returns zero if the symbol number is out of range, non-zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#a8f6f6ffff7ed12a048c8d4afcbe106fd">More...</a><br /></td></tr>
<tr class="separator:a8f6f6ffff7ed12a048c8d4afcbe106fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3c2e34e519e2f68e7ff57966bce35e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#adf3c2e34e519e2f68e7ff57966bce35e">gdxSymbolInfoX</a> (int SyNr, int &amp;RecCnt, int &amp;UserInfo, char *ExplTxt)</td></tr>
<tr class="memdesc:adf3c2e34e519e2f68e7ff57966bce35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns additional information about a symbol. Returns zero if the symbol number is out of range, non-zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#adf3c2e34e519e2f68e7ff57966bce35e">More...</a><br /></td></tr>
<tr class="separator:adf3c2e34e519e2f68e7ff57966bce35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fccb045a2f3eab80d4b091c8224376"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a96fccb045a2f3eab80d4b091c8224376">gdxSystemInfo</a> (int &amp;SyCnt, int &amp;UelCnt) const</td></tr>
<tr class="memdesc:a96fccb045a2f3eab80d4b091c8224376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of symbols and unique elements. Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#a96fccb045a2f3eab80d4b091c8224376">More...</a><br /></td></tr>
<tr class="separator:a96fccb045a2f3eab80d4b091c8224376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2bf255c16f8b630deffc448df61704"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ade2bf255c16f8b630deffc448df61704">gdxCurrentDim</a> () const</td></tr>
<tr class="memdesc:ade2bf255c16f8b630deffc448df61704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the currently active symbol When reading or writing data, the dimension of the current active symbol is sometimes needed to convert arguments from strings to pchars (char ) etc.  <a href="classgdx_1_1TGXFileObj.html#ade2bf255c16f8b630deffc448df61704">More...</a><br /></td></tr>
<tr class="separator:ade2bf255c16f8b630deffc448df61704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Text for UELs</div></td></tr>
<tr class="memitem:a1a35f810ade409dc201291bdb28c4ab2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a1a35f810ade409dc201291bdb28c4ab2">gdxAddSetText</a> (const char *Txt, int &amp;TxtNr)</td></tr>
<tr class="memdesc:a1a35f810ade409dc201291bdb28c4ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a string in the string table Register a string in the string table and return the integer number assigned to this string. The integer value can be used to set the associated text of a set element. The string must follow the GAMS syntax rules for explanatory text e.g. not longer than 255 characters.  <a href="classgdx_1_1TGXFileObj.html#a1a35f810ade409dc201291bdb28c4ab2">More...</a><br /></td></tr>
<tr class="separator:a1a35f810ade409dc201291bdb28c4ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada63dd0c8f185c863b19bd39304318d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ada63dd0c8f185c863b19bd39304318d5">gdxGetElemText</a> (int TxtNr, char *Txt, int &amp;Node)</td></tr>
<tr class="memdesc:ada63dd0c8f185c863b19bd39304318d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the string and node number for an entry in the string table. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#ada63dd0c8f185c863b19bd39304318d5">More...</a><br /></td></tr>
<tr class="separator:ada63dd0c8f185c863b19bd39304318d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3758f05c24a9cd2f777873a49e697ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ae3758f05c24a9cd2f777873a49e697ea">gdxSetHasText</a> (int SyNr)</td></tr>
<tr class="memdesc:ae3758f05c24a9cd2f777873a49e697ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if any of the elements of the set has an associated text. Non-zero if the Set contains at least one unique element that has associated text, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#ae3758f05c24a9cd2f777873a49e697ea">More...</a><br /></td></tr>
<tr class="separator:ae3758f05c24a9cd2f777873a49e697ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e17521127e04fb89454b49521c9be22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a2e17521127e04fb89454b49521c9be22">gdxSetTextNodeNr</a> (int TxtNr, int Node)</td></tr>
<tr class="memdesc:a2e17521127e04fb89454b49521c9be22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Node number for an entry in the string table. After registering a string with AddSetText, we can assign a node number for later retrieval. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a2e17521127e04fb89454b49521c9be22">More...</a><br /></td></tr>
<tr class="separator:a2e17521127e04fb89454b49521c9be22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unique elements</div></td></tr>
<tr class="memitem:aec362a592dc0213a5b21094a549053a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#aec362a592dc0213a5b21094a549053a5">gdxUELRegisterDone</a> ()</td></tr>
<tr class="memdesc:aec362a592dc0213a5b21094a549053a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish registration of unique elements. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#aec362a592dc0213a5b21094a549053a5">More...</a><br /></td></tr>
<tr class="separator:aec362a592dc0213a5b21094a549053a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9113a622565539f5ae9babd4633a9ccc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a9113a622565539f5ae9babd4633a9ccc">gdxUELRegisterMap</a> (int UMap, const char *Uel)</td></tr>
<tr class="memdesc:a9113a622565539f5ae9babd4633a9ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register unique element in mapped mode. A unique element must follow the GAMS rules when it contains quote characters. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a9113a622565539f5ae9babd4633a9ccc">More...</a><br /></td></tr>
<tr class="separator:a9113a622565539f5ae9babd4633a9ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2752ae59f395cc46e7333cca006439dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a2752ae59f395cc46e7333cca006439dc">gdxUELRegisterMapStart</a> ()</td></tr>
<tr class="memdesc:a2752ae59f395cc46e7333cca006439dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start registering unique elements in mapped mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a2752ae59f395cc46e7333cca006439dc">More...</a><br /></td></tr>
<tr class="separator:a2752ae59f395cc46e7333cca006439dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab4081a598f1a88e34c19a3a841dfa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a3ab4081a598f1a88e34c19a3a841dfa2">gdxUELRegisterRaw</a> (const char *Uel)</td></tr>
<tr class="memdesc:a3ab4081a598f1a88e34c19a3a841dfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register unique element in raw mode. This can only be used while writing to a GDX file. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a3ab4081a598f1a88e34c19a3a841dfa2">More...</a><br /></td></tr>
<tr class="separator:a3ab4081a598f1a88e34c19a3a841dfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39b863999089bcb61b5d58014603fb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#af39b863999089bcb61b5d58014603fb3">gdxUELRegisterRawStart</a> ()</td></tr>
<tr class="memdesc:af39b863999089bcb61b5d58014603fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start registering unique elements in raw mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#af39b863999089bcb61b5d58014603fb3">More...</a><br /></td></tr>
<tr class="separator:af39b863999089bcb61b5d58014603fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626c87515b7f8bb1527020845907a938"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a626c87515b7f8bb1527020845907a938">gdxUELRegisterStr</a> (const char *Uel, int &amp;UelNr)</td></tr>
<tr class="memdesc:a626c87515b7f8bb1527020845907a938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a unique element in string mode. A unique element must follow the GAMS rules when it contains quote characters. Non-zero if the element was registered, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#a626c87515b7f8bb1527020845907a938">More...</a><br /></td></tr>
<tr class="separator:a626c87515b7f8bb1527020845907a938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c27a9ff79464cc7d4f2be29e96cb22d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a1c27a9ff79464cc7d4f2be29e96cb22d">gdxUELRegisterStrStart</a> ()</td></tr>
<tr class="memdesc:a1c27a9ff79464cc7d4f2be29e96cb22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start registering unique elements in string mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a1c27a9ff79464cc7d4f2be29e96cb22d">More...</a><br /></td></tr>
<tr class="separator:a1c27a9ff79464cc7d4f2be29e96cb22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56b11d2fed8aeb94082880ab65b5d72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ab56b11d2fed8aeb94082880ab65b5d72">gdxUMFindUEL</a> (const char *Uel, int &amp;UelNr, int &amp;UelMap)</td></tr>
<tr class="memdesc:ab56b11d2fed8aeb94082880ab65b5d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for unique element by its string. Non-zero if the element was found, zero otherwise.  <a href="classgdx_1_1TGXFileObj.html#ab56b11d2fed8aeb94082880ab65b5d72">More...</a><br /></td></tr>
<tr class="separator:ab56b11d2fed8aeb94082880ab65b5d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa4bee81394262223a74e7283daa0f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a8aa4bee81394262223a74e7283daa0f0">gdxUMUelGet</a> (int UelNr, char *Uel, int &amp;UelMap)</td></tr>
<tr class="memdesc:a8aa4bee81394262223a74e7283daa0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a unique element using an unmapped index. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a8aa4bee81394262223a74e7283daa0f0">More...</a><br /></td></tr>
<tr class="separator:a8aa4bee81394262223a74e7283daa0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220668a85337531cec7984c9d757f5e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a220668a85337531cec7984c9d757f5e3">gdxUMUelInfo</a> (int &amp;UelCnt, int &amp;HighMap) const</td></tr>
<tr class="memdesc:a220668a85337531cec7984c9d757f5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return information about the unique elements (UELs). Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#a220668a85337531cec7984c9d757f5e3">More...</a><br /></td></tr>
<tr class="separator:a220668a85337531cec7984c9d757f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a4e636ae4d3e85b042c9a4b92fa075"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a36a4e636ae4d3e85b042c9a4b92fa075">gdxRenameUEL</a> (const char *OldName, const char *NewName)</td></tr>
<tr class="memdesc:a36a4e636ae4d3e85b042c9a4b92fa075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename unique element OldName to NewName.  <a href="classgdx_1_1TGXFileObj.html#a36a4e636ae4d3e85b042c9a4b92fa075">More...</a><br /></td></tr>
<tr class="separator:a36a4e636ae4d3e85b042c9a4b92fa075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Write Data</div></td></tr>
<tr class="memitem:a7f86b31fb404c071ada8b5a2c8e47bdf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a7f86b31fb404c071ada8b5a2c8e47bdf">gdxDataWriteDone</a> ()</td></tr>
<tr class="memdesc:a7f86b31fb404c071ada8b5a2c8e47bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a write operation. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a7f86b31fb404c071ada8b5a2c8e47bdf">More...</a><br /></td></tr>
<tr class="separator:a7f86b31fb404c071ada8b5a2c8e47bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d81038277636d111c3701987aa9b80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a91d81038277636d111c3701987aa9b80">gdxDataWriteMap</a> (const int *KeyInt, const double *Values)</td></tr>
<tr class="memdesc:a91d81038277636d111c3701987aa9b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a data element in mapped mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a91d81038277636d111c3701987aa9b80">More...</a><br /></td></tr>
<tr class="separator:a91d81038277636d111c3701987aa9b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7350fad4ba0a4010b6d53e62132937e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a7350fad4ba0a4010b6d53e62132937e6">gdxDataWriteMapStart</a> (const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo)</td></tr>
<tr class="memdesc:a7350fad4ba0a4010b6d53e62132937e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start writing a new symbol in mapped mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a7350fad4ba0a4010b6d53e62132937e6">More...</a><br /></td></tr>
<tr class="separator:a7350fad4ba0a4010b6d53e62132937e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08479eba2a07e327828b96098fbe14a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a08479eba2a07e327828b96098fbe14a6">gdxDataWriteRaw</a> (const int *KeyInt, const double *Values)</td></tr>
<tr class="memdesc:a08479eba2a07e327828b96098fbe14a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a data element in raw mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a08479eba2a07e327828b96098fbe14a6">More...</a><br /></td></tr>
<tr class="separator:a08479eba2a07e327828b96098fbe14a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353576e44e5c307a26726a870ec3f39d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a353576e44e5c307a26726a870ec3f39d">gdxDataWriteRawStart</a> (const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo)</td></tr>
<tr class="memdesc:a353576e44e5c307a26726a870ec3f39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start writing a new symbol in raw mode. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a353576e44e5c307a26726a870ec3f39d">More...</a><br /></td></tr>
<tr class="separator:a353576e44e5c307a26726a870ec3f39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdceb4091918007f4a4ca7819a43c20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a1fdceb4091918007f4a4ca7819a43c20">gdxDataWriteStr</a> (const char **KeyStr, const double *Values)</td></tr>
<tr class="memdesc:a1fdceb4091918007f4a4ca7819a43c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a data element in string mode. Each element string must follow the GAMS rules for unique elements. Returns zero if the operation is not possible.  <a href="classgdx_1_1TGXFileObj.html#a1fdceb4091918007f4a4ca7819a43c20">More...</a><br /></td></tr>
<tr class="separator:a1fdceb4091918007f4a4ca7819a43c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638d737c0364437390d5ffc731b31066"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a638d737c0364437390d5ffc731b31066">gdxDataWriteStrStart</a> (const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo)</td></tr>
<tr class="memdesc:a638d737c0364437390d5ffc731b31066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start writing a new symbol in string mode. Returns zero if the operation is not possible or failed.  <a href="classgdx_1_1TGXFileObj.html#a638d737c0364437390d5ffc731b31066">More...</a><br /></td></tr>
<tr class="separator:a638d737c0364437390d5ffc731b31066"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a858ab75a20b7a2e3863370d2126f9205"><td class="memItemLeft" align="right" valign="top"><a id="a858ab75a20b7a2e3863370d2126f9205" name="a858ab75a20b7a2e3863370d2126f9205"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>gdxGetDomainElements_DP_CallByRef</b> {}</td></tr>
<tr class="separator:a858ab75a20b7a2e3863370d2126f9205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4603627ff52b9a733d8bd739b42f506b"><td class="memItemLeft" align="right" valign="top"><a id="a4603627ff52b9a733d8bd739b42f506b" name="a4603627ff52b9a733d8bd739b42f506b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>gdxDataReadRawFastFilt_DP_CallByRef</b> {}</td></tr>
<tr class="separator:a4603627ff52b9a733d8bd739b42f506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa301ba783de393af58382b881fef421b"><td class="memItemLeft" align="right" valign="top"><a id="aa301ba783de393af58382b881fef421b" name="aa301ba783de393af58382b881fef421b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>gdxDataReadRawFastEx_DP_CallByRef</b> {}</td></tr>
<tr class="separator:aa301ba783de393af58382b881fef421b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Errors</h2></td></tr>
<tr class="memitem:ae3d45de882c24b8d2acdd47417bfc561"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#ae3d45de882c24b8d2acdd47417bfc561">gdxErrorCount</a> () const</td></tr>
<tr class="memdesc:ae3d45de882c24b8d2acdd47417bfc561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of errors.  <a href="classgdx_1_1TGXFileObj.html#ae3d45de882c24b8d2acdd47417bfc561">More...</a><br /></td></tr>
<tr class="separator:ae3d45de882c24b8d2acdd47417bfc561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35273506e085ef6d885f94724ca02b86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a35273506e085ef6d885f94724ca02b86">gdxGetLastError</a> ()</td></tr>
<tr class="memdesc:a35273506e085ef6d885f94724ca02b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last error number or zero if there was no error. Calling this function will clear the last error stored.  <a href="classgdx_1_1TGXFileObj.html#a35273506e085ef6d885f94724ca02b86">More...</a><br /></td></tr>
<tr class="separator:a35273506e085ef6d885f94724ca02b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cfa59bcabe31a143079f5dbd1fd3d6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a02cfa59bcabe31a143079f5dbd1fd3d6">gdxErrorStr</a> (int ErrNr, char *ErrMsg)</td></tr>
<tr class="memdesc:a02cfa59bcabe31a143079f5dbd1fd3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the text for a given error number. Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#a02cfa59bcabe31a143079f5dbd1fd3d6">More...</a><br /></td></tr>
<tr class="separator:a02cfa59bcabe31a143079f5dbd1fd3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Version/Information</h2></td></tr>
<tr class="memitem:a76137ca3e23d4e34e0cce16ffb34845a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a76137ca3e23d4e34e0cce16ffb34845a">gdxFileVersion</a> (char *FileStr, char *ProduceStr) const</td></tr>
<tr class="memdesc:a76137ca3e23d4e34e0cce16ffb34845a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return strings for file version and file producer. Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#a76137ca3e23d4e34e0cce16ffb34845a">More...</a><br /></td></tr>
<tr class="separator:a76137ca3e23d4e34e0cce16ffb34845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f40d7fd17618c9416464a480efc37b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a18f40d7fd17618c9416464a480efc37b">gdxSetTraceLevel</a> (int N, const char *s)</td></tr>
<tr class="memdesc:a18f40d7fd17618c9416464a480efc37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the amount of trace (debug) information generated. Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#a18f40d7fd17618c9416464a480efc37b">More...</a><br /></td></tr>
<tr class="separator:a18f40d7fd17618c9416464a480efc37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e38caa19cf9afd559432abd76f9868"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdx_1_1TGXFileObj.html#a29e38caa19cf9afd559432abd76f9868">gdxGetDLLVersion</a> (char *V)</td></tr>
<tr class="memdesc:a29e38caa19cf9afd559432abd76f9868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a version descriptor of the library. Always non-zero.  <a href="classgdx_1_1TGXFileObj.html#a29e38caa19cf9afd559432abd76f9868">More...</a><br /></td></tr>
<tr class="separator:a29e38caa19cf9afd559432abd76f9868"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Class for reading and writing GDX files through a efficient low-level interface </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aed5b4c956fa02b36eb37921fba82f945" name="aed5b4c956fa02b36eb37921fba82f945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5b4c956fa02b36eb37921fba82f945">&#9670;&#160;</a></span>TGXFileObj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gdx::TGXFileObj::TGXFileObj </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>ErrMsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new GDX file object. Does not open a file yet. </p>
<p >Constructor of GDX file object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ErrMsg</td><td>Out argument for storing potential error messages. Will be empty when there is no error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace0b322387deb11ac80960bfa27684a5" name="ace0b322387deb11ac80960bfa27684a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0b322387deb11ac80960bfa27684a5">&#9670;&#160;</a></span>~TGXFileObj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gdx::TGXFileObj::~TGXFileObj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispose GDX file object. </p>
<p >Destructor of GDX file object</p>
<p >Tears down a file GDX object and potentially closes (and flushes) a file opened for writing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa82277b5095243030de46f35491e3cb8" name="aa82277b5095243030de46f35491e3cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82277b5095243030de46f35491e3cb8">&#9670;&#160;</a></span>gdxAcronymAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAcronymAdd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>AName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AIndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new acronym entry. This can be used to add entries before data is written. Returns negative value (&lt;0) if the entry is not added. </p>
<p >This function can be used to add entries before data is written. When entries are added implicitly use gdxAcronymSetInfo to update the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AName</td><td>Name of the acronym (up to 63 characters) The first character of a symbol must be a letter. Following symbol characters may be letters, digits, and underscores. Symbol names must be new and unique. </td></tr>
    <tr><td class="paramname">Txt</td><td>Explanatory text of the acronym (up to 255 characters, mixed quotes will be unified to first occurring quote character). </td></tr>
    <tr><td class="paramname">AIndx</td><td>Index value of the acronym. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
0 If the entry is not added because of a duplicate name using the same value fo the index.  </li>
<li>
-1 If the entry is not added because of a duplicate name using a different value for the index.  </li>
<li>
Otherwise the index into the acronym table (1..gdxAcronymCount).  </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a0593d8da6fedf8237126611eae81485e" title="Retrieve acronym information from the acronym table. Non-zero if the index into the acronym table is ...">gdxAcronymGetInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ad80a7c83abf48f228ffb66dd136d373b" title="Number of entries in the acronym table.">gdxAcronymCount</a> </dd></dl>

</div>
</div>
<a id="ad80a7c83abf48f228ffb66dd136d373b" name="ad80a7c83abf48f228ffb66dd136d373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80a7c83abf48f228ffb66dd136d373b">&#9670;&#160;</a></span>gdxAcronymCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAcronymCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of entries in the acronym table. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of entries in the acronym table. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#afe7f6c210e407402fcb24ba63d4392a8" title="Modify acronym information in the acronym table.">gdxAcronymSetInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#afe7f6c210e407402fcb24ba63d4392a8" title="Modify acronym information in the acronym table.">gdxAcronymSetInfo</a> </dd></dl>

</div>
</div>
<a id="a0593d8da6fedf8237126611eae81485e" name="a0593d8da6fedf8237126611eae81485e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0593d8da6fedf8237126611eae81485e">&#9670;&#160;</a></span>gdxAcronymGetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAcronymGetInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>AName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>AIndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve acronym information from the acronym table. Non-zero if the index into the acronym table is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Index into acronym table (range 1..AcronymCount). </td></tr>
    <tr><td class="paramname">AName</td><td>Name of the acronym (up to 63 characters). </td></tr>
    <tr><td class="paramname">Txt</td><td>Explanatory text of the acronym (up to 255 characters, mixed quote chars will be unified to first occurring quote). </td></tr>
    <tr><td class="paramname">AIndx</td><td>Index value of the acronym. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Make sure AName is 64 bytes and Txt 256 bytes wide to prevent overflow! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the index into the acronym table is valid; false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#afe7f6c210e407402fcb24ba63d4392a8" title="Modify acronym information in the acronym table.">gdxAcronymSetInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ad80a7c83abf48f228ffb66dd136d373b" title="Number of entries in the acronym table.">gdxAcronymCount</a> </dd></dl>

</div>
</div>
<a id="adcc7c9a9290a8e60df48638b48e625c7" name="adcc7c9a9290a8e60df48638b48e625c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc7c9a9290a8e60df48638b48e625c7">&#9670;&#160;</a></span>gdxAcronymGetMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAcronymGetMapping </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>orgIndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>newIndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>autoIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information how acronym values are remapped. When reading GDX data, we need to map indices for acronyms used in the GDX file to indices used by the reading program. Non-zero if the index into the acronym table is valid. </p>
<p >When reading GDX data, we need to map indices for acronyms used in the GDX file to indices used by the reading program. There is a problem when not all acronyms have been registered before reading the GDX data. We need to map an undefined index we read to a new value. The value of NextAutoAcronym is used for that. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Index into acronym table; range from 1 to AcronymCount. </td></tr>
    <tr><td class="paramname">orgIndx</td><td>The Index used in the GDX file. </td></tr>
    <tr><td class="paramname">newIndx</td><td>The Index returned when reading GDX data. </td></tr>
    <tr><td class="paramname">autoIndex</td><td>Non-zero if the newIndx was generated using the value of NextAutoAcronym. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the index into the acronym table is valid; false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a0593d8da6fedf8237126611eae81485e" title="Retrieve acronym information from the acronym table. Non-zero if the index into the acronym table is ...">gdxAcronymGetInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ad80a7c83abf48f228ffb66dd136d373b" title="Number of entries in the acronym table.">gdxAcronymCount</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a7cc4c0e20c355cc8a91a65727e841d4d" title="Returns the value of the NextAutoAcronym variable and sets the variable to nv.">gdxAcronymNextNr</a> </dd></dl>

</div>
</div>
<a id="aa1979f01dacdbb2e2e0309d21fc778db" name="aa1979f01dacdbb2e2e0309d21fc778db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1979f01dacdbb2e2e0309d21fc778db">&#9670;&#160;</a></span>gdxAcronymIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAcronymIndex </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index value of an acronym. Returns zero if V does not represent an acronym. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Input value possibly representing an acronym/Version string after return (gdxGetDLLVersion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of acronym value V; zero if V does not represent an acronym. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a3171c1f888a68e2edf729e35da916f03" title="Create an acronym value based on the index (AIndx should be greater than 0). Returns the calculated a...">gdxAcronymValue</a> </dd></dl>

</div>
</div>
<a id="a6f71f613be88ee5af372289aa4db2342" name="a6f71f613be88ee5af372289aa4db2342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f71f613be88ee5af372289aa4db2342">&#9670;&#160;</a></span>gdxAcronymName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAcronymName </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>AName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the name of an acronym value. Non-zero if a name for the acronym is defined. An unnamed acronym value will return a string of the form UnknownAcronymNNN, were NNN is the index of the acronym. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Input value possibly containing an acronym/Version string after return (gdxGetDLLVersion). </td></tr>
    <tr><td class="paramname">AName</td><td>Name of acronym value or the empty string (can be up to 63 characters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Supplied buffer for AName should be 64 bytes long to prevent overflow! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Return non-zero if a name for the acronym is defined. Return zero if V does not represent an acronym value or a name is not defined. An unnamed acronym value will return a string of the form UnknownAcronymNNN; were NNN is the index of the acronym. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aa1979f01dacdbb2e2e0309d21fc778db" title="Get index value of an acronym. Returns zero if V does not represent an acronym.">gdxAcronymIndex</a> </dd></dl>

</div>
</div>
<a id="a7cc4c0e20c355cc8a91a65727e841d4d" name="a7cc4c0e20c355cc8a91a65727e841d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc4c0e20c355cc8a91a65727e841d4d">&#9670;&#160;</a></span>gdxAcronymNextNr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAcronymNextNr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NV</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the NextAutoAcronym variable and sets the variable to nv. </p>
<ul>
<li>
When we read from a GDX file and encounter an acronym that was not defined, we need to assign a new index for that acronym. The variable NextAutoAcronym is used for this purpose and is incremented for each new undefined acronym.  </li>
<li>
When NextAutoAcronym has a value of zero, the default, the value is ignored and the original index as stored in the GDX file is used for the index.  </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NV</td><td>New value for NextAutoAcronym; a value of less than zero is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous value of NextAutoAcronym. </dd></dl>

</div>
</div>
<a id="afe7f6c210e407402fcb24ba63d4392a8" name="afe7f6c210e407402fcb24ba63d4392a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7f6c210e407402fcb24ba63d4392a8">&#9670;&#160;</a></span>gdxAcronymSetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAcronymSetInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>AName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AIndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify acronym information in the acronym table. </p>
<ul>
<li>
When writing a GDX file, this function is used to provide the name of an acronym; in this case the Indx parameter must match.  </li>
<li>
When reading a GDX file, this function is used to provide the acronym index, and the AName parameter must match.  </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Index into acronym table (range 1..AcronymCount). </td></tr>
    <tr><td class="paramname">AName</td><td>Name of the acronym (up to 63 characters). The first character of a symbol must be a letter. Following symbol characters may be letters, digits, and underscores. Symbol names must be new and unique. </td></tr>
    <tr><td class="paramname">Txt</td><td>Explanatory text of the acronym (up to 255 characters, mixed quote chars will be unified to first occurring quote). </td></tr>
    <tr><td class="paramname">AIndx</td><td>Index value of the acronym. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the index into the acronym table is valid; false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a0593d8da6fedf8237126611eae81485e" title="Retrieve acronym information from the acronym table. Non-zero if the index into the acronym table is ...">gdxAcronymGetInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ad80a7c83abf48f228ffb66dd136d373b" title="Number of entries in the acronym table.">gdxAcronymCount</a> </dd></dl>

</div>
</div>
<a id="a3171c1f888a68e2edf729e35da916f03" name="a3171c1f888a68e2edf729e35da916f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3171c1f888a68e2edf729e35da916f03">&#9670;&#160;</a></span>gdxAcronymValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gdx::TGXFileObj::gdxAcronymValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AIndx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an acronym value based on the index (AIndx should be greater than 0). Returns the calculated acronym value (zero if AIndx is &lt;0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AIndx</td><td>Index value; should be greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated acronym value; zero if Indx is not positive. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aa1979f01dacdbb2e2e0309d21fc778db" title="Get index value of an acronym. Returns zero if V does not represent an acronym.">gdxAcronymIndex</a> </dd></dl>

</div>
</div>
<a id="ac38540e57b8b2b29a0f37a7842bf5706" name="ac38540e57b8b2b29a0f37a7842bf5706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38540e57b8b2b29a0f37a7842bf5706">&#9670;&#160;</a></span>gdxAddAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAddAlias </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an alias for a set to the symbol table. One of the two identifiers has to be a known set, an alias or "*" (universe); the other identifier is used as the new alias for the given set. The function gdxSymbolInfoX can be used to retrieve the set or alias associated with the identifier; it is returned as the UserInfo parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Id1</td><td>First set identifier. </td></tr>
    <tr><td class="paramname">Id2</td><td>Second set identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>One of the set identifiers must be a novel unique name. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a3955eaf00687760c2b7cdce9c9eb9fd7" title="Define the domain of a symbol for which a write data operation just started using DataWriteRawStart,...">gdxSymbolSetDomain</a> </dd></dl>

</div>
</div>
<a id="a1a35f810ade409dc201291bdb28c4ab2" name="a1a35f810ade409dc201291bdb28c4ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a35f810ade409dc201291bdb28c4ab2">&#9670;&#160;</a></span>gdxAddSetText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAddSetText </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>TxtNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a string in the string table Register a string in the string table and return the integer number assigned to this string. The integer value can be used to set the associated text of a set element. The string must follow the GAMS syntax rules for explanatory text e.g. not longer than 255 characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Txt</td><td>The string to be registered (must not exceed 255 characters). </td></tr>
    <tr><td class="paramname">TxtNr</td><td>The index number assigned to this string (output argument). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Mixing of single- and double-quotes in the explanatory text will be resolved by replacing all quote character occurrences with the first one in the text. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#ada63dd0c8f185c863b19bd39304318d5" title="Retrieve the string and node number for an entry in the string table. Returns zero if the operation i...">gdxGetElemText</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a2e17521127e04fb89454b49521c9be22" title="Set the Node number for an entry in the string table. After registering a string with AddSetText,...">gdxSetTextNodeNr</a> </dd></dl>

</div>
</div>
<a id="a8dbb4eac89440b34955ec4bdd97a3147" name="a8dbb4eac89440b34955ec4bdd97a3147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbb4eac89440b34955ec4bdd97a3147">&#9670;&#160;</a></span>gdxAllowBogusDomains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAllowBogusDomains </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flag to ignore using 1-dim sets as domain when their elements are not tracked (see gdxStoreDomainSets). In case the flag is enabled this is allowing potentially unsafe writing of records to symbols with one dimensional sets as domain, when GDX has no lookup table for the elements of this set. This can happen when <code>gdxStoreDomainSets</code> was disabled by the user to save memory. For backwards compatability, this is enabled by default. Return 1 (true) iff. using a 1-dim set as domain (when store domain sets option is disabled) should be ignored. Otherwise an error is raised (ERR_NODOMAINDATA). </p>
<dl class="section return"><dt>Returns</dt><dd>1 (true) iff. flag is set, 0 (false) otherwise. </dd></dl>

</div>
</div>
<a id="acb6f2da3823e3f3ac38cb7cd5ec1e376" name="acb6f2da3823e3f3ac38cb7cd5ec1e376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6f2da3823e3f3ac38cb7cd5ec1e376">&#9670;&#160;</a></span>gdxAllowBogusDomainsSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gdx::TGXFileObj::gdxAllowBogusDomainsSet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flag to ignore using 1-dim sets as domain when their elements are not tracked (see gdxStoreDomainSets). Toggle allowing potentially unsafe writing of records to symbols with one dimensional sets as domain, when GDX has no lookup table for the elements of this set. This can happen when <code>gdxStoreDomainSets</code> was disabled by the user to save memory. For backwards compatability, this is enabled by default. When the user explicitly disables it, e.g. via <code>gdxAllowBogusDomainsSet(false)</code>, then using a one dimensional set as domain will cause a GDX error (ERR_NODOMAINDATA). Param flag 1 (true) iff. using a 1-dim set as domain (when store domain sets option is disabled) should be ignored. Otherwise an error is raised (ERR_NODOMAINDATA). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>1 (true) to enable and 0 (false) to disable flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0b2458fa7062edde0eedde8fc5ec40a" name="ae0b2458fa7062edde0eedde8fc5ec40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b2458fa7062edde0eedde8fc5ec40a">&#9670;&#160;</a></span>gdxAutoConvert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxAutoConvert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NV</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the AutoConvert variable and sets the variable to nv. When we close a new GDX file, we look at the value of AutoConvert; if AutoConvert is non-zero, we look at the GDXCOMPRESS and GDXCONVERT environment variables to determine if conversion to an older file format is desired. We needed this logic so gdxcopy.exe can disable automatic file conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NV</td><td>New value for AutoConvert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous value of AutoConvert. </dd></dl>

</div>
</div>
<a id="a871263601526037bc936b71389813e0b" name="a871263601526037bc936b71389813e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871263601526037bc936b71389813e0b">&#9670;&#160;</a></span>gdxClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxClose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a GDX file that was previously opened for reading or writing. Before the file is closed, any pending write operations will be finished. This does not free the GDX in-memory object. This method will automatically be called when the GDX object lifetime ends (e.g. being out of scope). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of gdxGetLastError. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a4a3b3e0ffdf3bbb17070e43ba7e98408" title="Open a GDX file for reading. Non-zero if the file can be opened, zero otherwise.">gdxOpenRead</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ae53f311244734378f4de7c9c7eafdf67" title="Open a new GDX file for output. Non-zero if the file can be opened, zero otherwise.">gdxOpenWrite</a> </dd></dl>

</div>
</div>
<a id="ade2bf255c16f8b630deffc448df61704" name="ade2bf255c16f8b630deffc448df61704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2bf255c16f8b630deffc448df61704">&#9670;&#160;</a></span>gdxCurrentDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxCurrentDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dimension of the currently active symbol When reading or writing data, the dimension of the current active symbol is sometimes needed to convert arguments from strings to pchars (char ) etc. </p>
<p >When reading or writing data, the dimension of the current active symbol is sometimes needed to convert arguments from strings to pchars (char ) etc. The currently active symbol is selected e.g. by starting a write- or read-operation and choosing its symbol number (SyNr). </p><dl class="section return"><dt>Returns</dt><dd>Dimension of current active symbol. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a895ee00426e6ec788879d394d484dad9" title="Initialize the reading of a symbol in raw mode. Returns zero if the operation is not possible.">gdxDataReadRawStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a353576e44e5c307a26726a870ec3f39d" title="Start writing a new symbol in raw mode. Returns zero if the operation is not possible.">gdxDataWriteRawStart</a> </dd></dl>

</div>
</div>
<a id="aaae21ed2293db76cdbd05dd06a94a775" name="aaae21ed2293db76cdbd05dd06a94a775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae21ed2293db76cdbd05dd06a94a775">&#9670;&#160;</a></span>gdxDataErrorCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataErrorCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of error records. </p>
<p >After a write operation is finished (with gdxDataWriteDone), the data is sorted and written to the GDX file (for map- and string-mode). If there are duplicate records, the first record is written to the file and the duplicates are added to the error list. When reading data using a filtered read operation, data records that were filtered out because an index is not in the user index space or not in a filter are added the error list. </p><dl class="section return"><dt>Returns</dt><dd>The number of error records available. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a36c5e9b87188458bfca1d08e4595f4d7" title="Retrieve an error record. Non-zero if the record number is valid.">gdxDataErrorRecord</a> </dd></dl>

</div>
</div>
<a id="a36c5e9b87188458bfca1d08e4595f4d7" name="a36c5e9b87188458bfca1d08e4595f4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c5e9b87188458bfca1d08e4595f4d7">&#9670;&#160;</a></span>gdxDataErrorRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataErrorRecord </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>RecNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>KeyInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an error record. Non-zero if the record number is valid. </p>
<p >Does not indicate domain violation for filtered/strict read with negative indices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RecNr</td><td>The number of the record to be retrieved (range = 1..NrErrorRecords); this argument is ignored in gdxDataReadMap </td></tr>
    <tr><td class="paramname">KeyInt</td><td>Index for the record (array of UEL numbers for each dimension). </td></tr>
    <tr><td class="paramname">Values</td><td>Values for the record (level, marginal, lower-, upper-bound, scale). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><ul>
<li>
Same as gdxDataErrorRecordX but negative UEL index numbers (for domain violations) are inverted, so the index is always &gt;=0.  </li>
<li>
KeyInt must be big enough to hold one UEL index for each dimension! Values must have length &gt;=5.  </li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the record number is valid, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aaae21ed2293db76cdbd05dd06a94a775" title="Query the number of error records.">gdxDataErrorCount</a> </dd></dl>

</div>
</div>
<a id="a6ddc3f2a9c1bdf0fe2f947350755d8e4" name="a6ddc3f2a9c1bdf0fe2f947350755d8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddc3f2a9c1bdf0fe2f947350755d8e4">&#9670;&#160;</a></span>gdxDataErrorRecordX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataErrorRecordX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>RecNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>KeyInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an error record. Non-zero if the record number is valid. </p>
<p >Also indicate domain violations for filtered/strict read with negative UEL index values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RecNr</td><td>The number of the record to be retrieved, (range 1..NrErrorRecords); this argument is ignored in gdxDataReadMap </td></tr>
    <tr><td class="paramname">KeyInt</td><td>Index for the record, negative uel indicates domain violation for filtered/strict read. </td></tr>
    <tr><td class="paramname">Values</td><td>Values for the record (level, marginal, lower-, upper-bound, scale). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><ul>
<li>
KeyInt must be big enough to hold one UEL index for each dimension!  </li>
<li>
Values must have length &gt;=5.  </li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the record number is valid, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aaae21ed2293db76cdbd05dd06a94a775" title="Query the number of error records.">gdxDataErrorCount</a> </dd></dl>

</div>
</div>
<a id="a99b5065af58cecb5ae945069a9d62a7c" name="a99b5065af58cecb5ae945069a9d62a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b5065af58cecb5ae945069a9d62a7c">&#9670;&#160;</a></span>gdxDataReadDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not possible. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a895ee00426e6ec788879d394d484dad9" title="Initialize the reading of a symbol in raw mode. Returns zero if the operation is not possible.">gdxDataReadRawStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a83e98f4facd1e175c214e45e31172e54" title="Initialize the reading of a symbol in mapped mode. Returns zero if the operation is not possible.">gdxDataReadMapStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aed3db6bbe6a4820809df84c38387735a" title="Initialize the reading of a symbol in string mode. Returns zero if the operation is not possible.">gdxDataReadStrStart</a> </dd></dl>

</div>
</div>
<a id="a0c9314cf277f2e61c7f3c2301cdfe54f" name="a0c9314cf277f2e61c7f3c2301cdfe54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9314cf277f2e61c7f3c2301cdfe54f">&#9670;&#160;</a></span>gdxDataReadFilteredStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadFilteredStart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>FilterAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NrRecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the reading of a symbol in filtered mode. Returns zero if the operation is not possible. </p>
<p >Start reading data for a symbol in filtered mode. Each filter action (1..Dimension) describes how each index should be treated when reading a data record. When new unique elements are returned, they are added to the user index space automatically. The actual reading of records is done with DataReadMap.</p>
<p >The action codes are as follows: </p><table class="doxtable">
<tr>
<td>Action code  </td><td>Result   </td></tr>
<tr>
<td>DOMC_UNMAPPED  </td><td>The index is not mapped into user space   </td></tr>
<tr>
<td>DOMC_EXPAND  </td><td>New unique elements encountered will be mapped into the user space   </td></tr>
<tr>
<td>DOMC_STRICT  </td><td>If the unique element in this position does not map into user space, the record will not be available and is added to the error list instead   </td></tr>
<tr>
<td>FilterNumber  </td><td>If the unique element in this position does not map into user space or is not enabled in this filter, the record will not be available and is added to the error list instead   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol, range 0..NrSymbols; SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">FilterAction</td><td>Array of filter actions for each index position. </td></tr>
    <tr><td class="paramname">NrRecs</td><td>The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a26dfa9d52a679851a308d58636e836b4" title="Define a unique element filter. Returns zero if the operation is not possible.">gdxFilterRegisterStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ab4009a92eba081f08a7f8ccaed7856e8" title="Read the next record in mapped mode. Returns zero if the operation is not possible.">gdxDataReadMap</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a895ee00426e6ec788879d394d484dad9" title="Initialize the reading of a symbol in raw mode. Returns zero if the operation is not possible.">gdxDataReadRawStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aed3db6bbe6a4820809df84c38387735a" title="Initialize the reading of a symbol in string mode. Returns zero if the operation is not possible.">gdxDataReadStrStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="ab4009a92eba081f08a7f8ccaed7856e8" name="ab4009a92eba081f08a7f8ccaed7856e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4009a92eba081f08a7f8ccaed7856e8">&#9670;&#160;</a></span>gdxDataReadMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>RecNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>KeyInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>DimFrst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next record in mapped mode. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RecNr</td><td>Ignored (left in for backward compatibility). </td></tr>
    <tr><td class="paramname">KeyInt</td><td>The index of the record. </td></tr>
    <tr><td class="paramname">Values</td><td>The data of the record. </td></tr>
    <tr><td class="paramname">DimFrst</td><td>The first index position in KeyInt that changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a83e98f4facd1e175c214e45e31172e54" title="Initialize the reading of a symbol in mapped mode. Returns zero if the operation is not possible.">gdxDataReadMapStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a0c9314cf277f2e61c7f3c2301cdfe54f" title="Initialize the reading of a symbol in filtered mode. Returns zero if the operation is not possible.">gdxDataReadFilteredStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="a83e98f4facd1e175c214e45e31172e54" name="a83e98f4facd1e175c214e45e31172e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e98f4facd1e175c214e45e31172e54">&#9670;&#160;</a></span>gdxDataReadMapStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadMapStart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NrRecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the reading of a symbol in mapped mode. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol, range 0..NrSymbols; SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">NrRecs</td><td>The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#ab4009a92eba081f08a7f8ccaed7856e8" title="Read the next record in mapped mode. Returns zero if the operation is not possible.">gdxDataReadMap</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a895ee00426e6ec788879d394d484dad9" title="Initialize the reading of a symbol in raw mode. Returns zero if the operation is not possible.">gdxDataReadRawStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aed3db6bbe6a4820809df84c38387735a" title="Initialize the reading of a symbol in string mode. Returns zero if the operation is not possible.">gdxDataReadStrStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="a81311547743068a58c162e4fdbf7b063" name="a81311547743068a58c162e4fdbf7b063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81311547743068a58c162e4fdbf7b063">&#9670;&#160;</a></span>gdxDataReadRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadRaw </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>KeyInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>DimFrst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next record in raw mode. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KeyInt</td><td>The index of the record in UEL numbers for each dimension. </td></tr>
    <tr><td class="paramname">Values</td><td>The data of the record (level, marginal, lower-, upper-bound, scale). </td></tr>
    <tr><td class="paramname">DimFrst</td><td>The first index position in KeyInt that changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>KeyInt must be big enough to hold one UEL index for each dimension! Values must have length &gt;=5. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise (e.g. no records left). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a895ee00426e6ec788879d394d484dad9" title="Initialize the reading of a symbol in raw mode. Returns zero if the operation is not possible.">gdxDataReadRawStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="a34e7d780747818f4fc7deaf0e6e71f0c" name="a34e7d780747818f4fc7deaf0e6e71f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e7d780747818f4fc7deaf0e6e71f0c">&#9670;&#160;</a></span>gdxDataReadRawFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadRawFast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDataStoreProc_t&#160;</td>
          <td class="paramname"><em>DP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NrRecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a symbol in Raw mode using a callback procedure. Returns zero if the operation is not possible. </p>
<p >Use a callback function to read a symbol in raw mode. Using a callback procedure to read the data is faster because we no longer have to check the context for each call to read a record. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol (range 0..NrSymbols); SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">DP</td><td>Procedure that will be called for each data record. This procedure (return type=void) should have the following signature: <ul>
<li>
UEL index number keys (const int ),  </li>
<li>
values (level, marginal, lower-, upper-bound, scale) (const double )  </li>
</ul>
</td></tr>
    <tr><td class="paramname">NrRecs</td><td>The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a81311547743068a58c162e4fdbf7b063" title="Read the next record in raw mode. Returns zero if the operation is not possible.">gdxDataReadRaw</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a83e98f4facd1e175c214e45e31172e54" title="Initialize the reading of a symbol in mapped mode. Returns zero if the operation is not possible.">gdxDataReadMapStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aed3db6bbe6a4820809df84c38387735a" title="Initialize the reading of a symbol in string mode. Returns zero if the operation is not possible.">gdxDataReadStrStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a014bf6aef956e6fbc0536e40c0cfb42f" title="Read a symbol in Raw mode while applying a filter using a callback procedure. Returns zero if the ope...">gdxDataReadRawFastFilt</a> </dd></dl>

</div>
</div>
<a id="abeb5de98a6e194622ac0685f8c3fdbc9" name="abeb5de98a6e194622ac0685f8c3fdbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb5de98a6e194622ac0685f8c3fdbc9">&#9670;&#160;</a></span>gdxDataReadRawFastEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadRawFastEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDataStoreExProc_t&#160;</td>
          <td class="paramname"><em>DP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NrRecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Uptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a symbol in Raw mode using a callback procedure. Returns zero if the operation is not possible. </p>
<p >Use a callback function to read a symbol in raw mode. Using a callback procedure to read the data is faster because we no longer have to check the context for each call to read a record. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol (range 0..NrSymbols); SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">DP</td><td>Procedure that will be called for each data record. This function (return type=integer) should return whether reading continues (=0 for stop, &gt;=1 otherwise) and should have the following signature: <ul>
<li>
UEL index number keys (const int ),  </li>
<li>
values (level, marginal, lower-, upper-bound, scale) (const double ),  </li>
<li>
dimension of first change (int),  </li>
<li>
pointer to custom data (void )  </li>
</ul>
</td></tr>
    <tr><td class="paramname">NrRecs</td><td>The number of records available for reading. </td></tr>
    <tr><td class="paramname">Uptr</td><td>Pointer to user memory that will be passed back with the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a34e7d780747818f4fc7deaf0e6e71f0c" title="Read a symbol in Raw mode using a callback procedure. Returns zero if the operation is not possible.">gdxDataReadRawFast</a> </dd></dl>

</div>
</div>
<a id="a014bf6aef956e6fbc0536e40c0cfb42f" name="a014bf6aef956e6fbc0536e40c0cfb42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014bf6aef956e6fbc0536e40c0cfb42f">&#9670;&#160;</a></span>gdxDataReadRawFastFilt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadRawFastFilt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>UelFilterStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDataStoreFiltProc_t&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a symbol in Raw mode while applying a filter using a callback procedure. Returns zero if the operation is not possible. </p>
<p >Read a slice of data, by fixing zero or more index positions in the data. When a data element is available, the callback procedure DP is called with the current index (as raw numbers) and the values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">UelFilterStr</td><td>Each index can be fixed by setting the string for the unique element. Set an index position to the empty string in order not to fix that position. If the string is not-empty it should match an UEL name from the UEL table. </td></tr>
    <tr><td class="paramname">DP</td><td>Callback procedure which will be called for each available data item. This procedure (return type=void) should have the following signature: <ul>
<li>
UEL index number keys (const int ),  </li>
<li>
values (level, marginal, lower-, upper-bound, scale) (const double ),  </li>
<li>
pointer to custom data (void ).  </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. <div class="fragment"><div class="line"><span class="keyword">auto</span> DPCallBack = [](<span class="keyword">const</span> <span class="keywordtype">int</span> *Indx, <span class="keyword">const</span> <span class="keywordtype">double</span> *Vals, <span class="keywordtype">void</span> *Uptr)</div>
<div class="line">{</div>
<div class="line">  std::string s;</div>
<div class="line">  <span class="keywordtype">int</span> UelMap;</div>
<div class="line">  ((<a class="code hl_class" href="classgdx_1_1TGXFileObj.html">TGXFileObj</a>*)Uptr).gdxUMUelGet(Indx[1], s, UelMap);</div>
<div class="line">  std::cout &lt;&lt; s &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; Vals[vallevel] &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">};</div>
<div class="line">TgdxStrIndex IndxS;</div>
<div class="line">IndxS[0] = <span class="stringliteral">&quot;i200&quot;</span>; IndxS[1] = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">pgx.gdxDataReadRawFastFilt(1, IndxS, DPCallBack);</div>
<div class="ttc" id="aclassgdx_1_1TGXFileObj_html"><div class="ttname"><a href="classgdx_1_1TGXFileObj.html">gdx::TGXFileObj</a></div><div class="ttdef"><b>Definition:</b> gdx.h:37</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a34e7d780747818f4fc7deaf0e6e71f0c" title="Read a symbol in Raw mode using a callback procedure. Returns zero if the operation is not possible.">gdxDataReadRawFast</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a762d113f3c6f11a268a18d46b0981220" title="Prepare for the reading of a slice of data from a data set. The actual read of the data is done by ca...">gdxDataReadSliceStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a86835775ac2e5124e883d1f4e2678582" title="Map a slice index in to the corresponding unique elements. After calling DataReadSliceStart,...">gdxDataSliceUELS</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="a895ee00426e6ec788879d394d484dad9" name="a895ee00426e6ec788879d394d484dad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895ee00426e6ec788879d394d484dad9">&#9670;&#160;</a></span>gdxDataReadRawStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadRawStart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NrRecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the reading of a symbol in raw mode. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol, range 0..NrSymbols; SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">NrRecs</td><td>The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a81311547743068a58c162e4fdbf7b063" title="Read the next record in raw mode. Returns zero if the operation is not possible.">gdxDataReadRaw</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a83e98f4facd1e175c214e45e31172e54" title="Initialize the reading of a symbol in mapped mode. Returns zero if the operation is not possible.">gdxDataReadMapStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aed3db6bbe6a4820809df84c38387735a" title="Initialize the reading of a symbol in string mode. Returns zero if the operation is not possible.">gdxDataReadStrStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="aa8990e8e89f522a1e1eee79e6ea49fbf" name="aa8990e8e89f522a1e1eee79e6ea49fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8990e8e89f522a1e1eee79e6ea49fbf">&#9670;&#160;</a></span>gdxDataReadSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadSlice </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>UelFilterStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Dimen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDataStoreProc_t&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a slice of data from a data set, by fixing zero or more index positions in the data. When a data element is available, the callback procedure DP is called with the current index and the values. The indices used in the index vary from zero to the highest value minus one for that index position. This function can be called multiple times. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UelFilterStr</td><td>Each index can be fixed by setting the string for the unique element. Set an index position to the empty string in order not to fix that position. </td></tr>
    <tr><td class="paramname">Dimen</td><td>The dimension of the index space; this is the number of index positions that is not fixed. </td></tr>
    <tr><td class="paramname">DP</td><td>Callback procedure which will be called for each available data item. Signature is <ul>
<li>
UEL index number keys for each symbol dimension (const int )  </li>
<li>
5 double values (const double )  </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Supply one UEL filter str for each symbol dimension (up to 63 characters per str). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a762d113f3c6f11a268a18d46b0981220" title="Prepare for the reading of a slice of data from a data set. The actual read of the data is done by ca...">gdxDataReadSliceStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a86835775ac2e5124e883d1f4e2678582" title="Map a slice index in to the corresponding unique elements. After calling DataReadSliceStart,...">gdxDataSliceUELS</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="a762d113f3c6f11a268a18d46b0981220" name="a762d113f3c6f11a268a18d46b0981220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762d113f3c6f11a268a18d46b0981220">&#9670;&#160;</a></span>gdxDataReadSliceStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadSliceStart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ElemCounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare for the reading of a slice of data from a data set. The actual read of the data is done by calling gdxDataReadSlice. When finished reading, call gdxDataReadDone. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>Symbol number to read, range 1..NrSymbols; SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">ElemCounts</td><td>Array of integers, each position indicating the number of unique indices in that position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aa8990e8e89f522a1e1eee79e6ea49fbf" title="Read a slice of data from a data set, by fixing zero or more index positions in the data....">gdxDataReadSlice</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="a7f0ab73d8dee5f9e499e1bd7ce5f9ce1" name="a7f0ab73d8dee5f9e499e1bd7ce5f9ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0ab73d8dee5f9e499e1bd7ce5f9ce1">&#9670;&#160;</a></span>gdxDataReadStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadStr </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>KeyStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>DimFrst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next record using strings for the unique elements. The reading should be initialized by calling DataReadStrStart. Returns zero if the operation is not possible or if there is no more data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KeyStr</td><td>The index of the record as strings for the unique elements. Array of strings with one string for each dimension. </td></tr>
    <tr><td class="paramname">Values</td><td>The data of the record (level, marginal, lower-, upper-bound, scale). </td></tr>
    <tr><td class="paramname">DimFrst</td><td>The first index position in KeyStr that changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>KeyStr must point to one string for each symbol dimension where each string buffer must have size of 64 bytes. Values must have length &gt;=5 double entries.</dd></dl>
<p>' </p><dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible; return zero if the operation is not possible or if there is no more data. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aed3db6bbe6a4820809df84c38387735a" title="Initialize the reading of a symbol in string mode. Returns zero if the operation is not possible.">gdxDataReadStrStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="aed3db6bbe6a4820809df84c38387735a" name="aed3db6bbe6a4820809df84c38387735a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3db6bbe6a4820809df84c38387735a">&#9670;&#160;</a></span>gdxDataReadStrStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataReadStrStart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NrRecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the reading of a symbol in string mode. Returns zero if the operation is not possible. </p>
<p >Reading data using strings is the simplest way to read data. Every record read using DataReadStr will return the strings for the unique elements. Internal mapping is not affected by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol (range 0..NrSymbols); SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">NrRecs</td><td>The maximum number of records available for reading. The actual number of records may be less when a filter is applied to the records read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. <div class="fragment"><div class="line"><span class="keywordflow">if</span>(pgx.gdxDataReadStrStart(1,NrRecs)) {</div>
<div class="line">  <span class="keywordflow">while</span>(pgx.gdxDataReadStr(Uels,Vals)) {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  pgx.gdxDataReadDone();</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a7f0ab73d8dee5f9e499e1bd7ce5f9ce1" title="Read the next record using strings for the unique elements. The reading should be initialized by call...">gdxDataReadStr</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a895ee00426e6ec788879d394d484dad9" title="Initialize the reading of a symbol in raw mode. Returns zero if the operation is not possible.">gdxDataReadRawStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a83e98f4facd1e175c214e45e31172e54" title="Initialize the reading of a symbol in mapped mode. Returns zero if the operation is not possible.">gdxDataReadMapStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="a86835775ac2e5124e883d1f4e2678582" name="a86835775ac2e5124e883d1f4e2678582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86835775ac2e5124e883d1f4e2678582">&#9670;&#160;</a></span>gdxDataSliceUELS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataSliceUELS </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>SliceKeyInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>KeyStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a slice index in to the corresponding unique elements. After calling DataReadSliceStart, each index position is mapped from 0 to N(d)-1. This function maps this index space back in to unique elements represented as strings. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SliceKeyInt</td><td>The slice index to be mapped to strings with one entry for each symbol dimension. </td></tr>
    <tr><td class="paramname">KeyStr</td><td>Array of strings containing the unique elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Both SliceKeyInt and KeyStr should match the symbol dimension with their length The string buffers pointed to by KeyStr should each be at least 64 bytes long to store up to 63 character UEL names. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a762d113f3c6f11a268a18d46b0981220" title="Prepare for the reading of a slice of data from a data set. The actual read of the data is done by ca...">gdxDataReadSliceStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a99b5065af58cecb5ae945069a9d62a7c" title="Finish reading of a symbol in any mode (raw, mapped, string). . Returns zero if the operation is not ...">gdxDataReadDone</a> </dd></dl>

</div>
</div>
<a id="a7f86b31fb404c071ada8b5a2c8e47bdf" name="a7f86b31fb404c071ada8b5a2c8e47bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f86b31fb404c071ada8b5a2c8e47bdf">&#9670;&#160;</a></span>gdxDataWriteDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataWriteDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish a write operation. Returns zero if the operation is not possible. </p>
<p >For mapped- and string-mode the actual writing of the records to the GDX file happens here. </p><dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aaae21ed2293db76cdbd05dd06a94a775" title="Query the number of error records.">gdxDataErrorCount</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a353576e44e5c307a26726a870ec3f39d" title="Start writing a new symbol in raw mode. Returns zero if the operation is not possible.">gdxDataWriteRawStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a7350fad4ba0a4010b6d53e62132937e6" title="Start writing a new symbol in mapped mode. Returns zero if the operation is not possible.">gdxDataWriteMapStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a638d737c0364437390d5ffc731b31066" title="Start writing a new symbol in string mode. Returns zero if the operation is not possible or failed.">gdxDataWriteStrStart</a> </dd></dl>

</div>
</div>
<a id="a91d81038277636d111c3701987aa9b80" name="a91d81038277636d111c3701987aa9b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d81038277636d111c3701987aa9b80">&#9670;&#160;</a></span>gdxDataWriteMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataWriteMap </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>KeyInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a data element in mapped mode. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KeyInt</td><td>The index for this element using mapped values. </td></tr>
    <tr><td class="paramname">Values</td><td>The values for this element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a7350fad4ba0a4010b6d53e62132937e6" title="Start writing a new symbol in mapped mode. Returns zero if the operation is not possible.">gdxDataWriteMapStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a7f86b31fb404c071ada8b5a2c8e47bdf" title="Finish a write operation. Returns zero if the operation is not possible.">gdxDataWriteDone</a> </dd></dl>

</div>
</div>
<a id="a7350fad4ba0a4010b6d53e62132937e6" name="a7350fad4ba0a4010b6d53e62132937e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7350fad4ba0a4010b6d53e62132937e6">&#9670;&#160;</a></span>gdxDataWriteMapStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataWriteMapStart </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>SyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ExplTxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Dimen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Typ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UserInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start writing a new symbol in mapped mode. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyId</td><td>Name of the symbol (up to 63 characters) or acronym. The first character of a symbol must be a letter. Following symbol characters may be letters, digits, and underscores. Symbol names must be new and unique. Might be an empty string at gdxAcronymName. </td></tr>
    <tr><td class="paramname">ExplTxt</td><td>Explanatory text for the symbol (up to 255 characters). </td></tr>
    <tr><td class="paramname">Dimen</td><td>Dimension of the symbol. </td></tr>
    <tr><td class="paramname">Typ</td><td>Type of the symbol. </td></tr>
    <tr><td class="paramname">UserInfo</td><td>User field value storing additional data; GAMS follows the following conventions: <table class="doxtable">
<tr>
<td>Type  </td><td>Value(s)   </td></tr>
<tr>
<td>Aliased Set  </td><td>The symbol number of the aliased set, or zero for the universe   </td></tr>
<tr>
<td>Set  </td><td>Zero   </td></tr>
<tr>
<td>Parameter  </td><td>Zero   </td></tr>
<tr>
<td>Variable  </td><td>The variable type: binary=1, integer=2, positive=3, negative=4, free=5, sos1=6, sos2=7, semicontinous=8, semiinteger=9   </td></tr>
<tr>
<td>Equation  </td><td>The equation type: eque=53, equg=54, equl=55, equn=56, equx=57, equc=58, equb=59   </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a91d81038277636d111c3701987aa9b80" title="Write a data element in mapped mode. Returns zero if the operation is not possible.">gdxDataWriteMap</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a7f86b31fb404c071ada8b5a2c8e47bdf" title="Finish a write operation. Returns zero if the operation is not possible.">gdxDataWriteDone</a> </dd></dl>

</div>
</div>
<a id="a08479eba2a07e327828b96098fbe14a6" name="a08479eba2a07e327828b96098fbe14a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08479eba2a07e327828b96098fbe14a6">&#9670;&#160;</a></span>gdxDataWriteRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataWriteRaw </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>KeyInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a data element in raw mode. Returns zero if the operation is not possible. </p>
<p >When writing data in raw mode, the index space used is based on the internal index space. The indices used are in the range 1..NrUels but this is not enforced. Before we can write in raw mode, the unique elements (strings) should be registered first. When writing raw, it assumed that the records are written in sorted order and that there are no duplicate records. Records that are not in sorted order or are duplicates will be added to the error list (see DataErrorCount and DataErrorRecord). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KeyInt</td><td>The index for this element. </td></tr>
    <tr><td class="paramname">Values</td><td>The values for this element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a353576e44e5c307a26726a870ec3f39d" title="Start writing a new symbol in raw mode. Returns zero if the operation is not possible.">gdxDataWriteRawStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a7f86b31fb404c071ada8b5a2c8e47bdf" title="Finish a write operation. Returns zero if the operation is not possible.">gdxDataWriteDone</a> </dd></dl>

</div>
</div>
<a id="a353576e44e5c307a26726a870ec3f39d" name="a353576e44e5c307a26726a870ec3f39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353576e44e5c307a26726a870ec3f39d">&#9670;&#160;</a></span>gdxDataWriteRawStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataWriteRawStart </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>SyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ExplTxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Dimen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Typ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UserInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start writing a new symbol in raw mode. Returns zero if the operation is not possible. </p>
<p >Raw mode flushes new records immediately to the GDX file (unlike mapped or string mode). The key indices for the record are provided as unique element numbers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyId</td><td>Name of the symbol (up to 63 characters). The first character of a symbol must be a letter. Following symbol characters may be letters, digits, and underscores. Symbol names must be new and unique. </td></tr>
    <tr><td class="paramname">ExplTxt</td><td>Explanatory text for the symbol (up to 255 characters). </td></tr>
    <tr><td class="paramname">Dimen</td><td>Dimension of the symbol (up to 20). </td></tr>
    <tr><td class="paramname">Typ</td><td>Type of the symbol (set=0, parameter=1, variable=2, equation=3, alias=4). </td></tr>
    <tr><td class="paramname">UserInfo</td><td>User field value storing additional data; GAMS follows the following conventions: <table class="doxtable">
<tr>
<td>Type  </td><td>Value(s)   </td></tr>
<tr>
<td>Aliased Set  </td><td>The symbol number of the aliased set, or zero for the universe   </td></tr>
<tr>
<td>Set  </td><td>Zero   </td></tr>
<tr>
<td>Parameter  </td><td>Zero   </td></tr>
<tr>
<td>Variable  </td><td>The variable type: binary=1, integer=2, positive=3, negative=4, free=5, sos1=6, sos2=7, semicontinous=8, semiinteger=9   </td></tr>
<tr>
<td>Equation  </td><td>The equation type: eque=53, equg=54, equl=55, equn=56, equx=57, equc=58, equb=59   </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a08479eba2a07e327828b96098fbe14a6" title="Write a data element in raw mode. Returns zero if the operation is not possible.">gdxDataWriteRaw</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a7f86b31fb404c071ada8b5a2c8e47bdf" title="Finish a write operation. Returns zero if the operation is not possible.">gdxDataWriteDone</a> </dd></dl>

</div>
</div>
<a id="a1fdceb4091918007f4a4ca7819a43c20" name="a1fdceb4091918007f4a4ca7819a43c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdceb4091918007f4a4ca7819a43c20">&#9670;&#160;</a></span>gdxDataWriteStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataWriteStr </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>KeyStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a data element in string mode. Each element string must follow the GAMS rules for unique elements. Returns zero if the operation is not possible. </p>
<ul>
<li>
When writing data using string elements, each string element is added to the internal unique element (UEL) table and assigned an index.  </li>
<li>
Writing using strings does not add the unique elements to the user mapped space.  </li>
<li>
Each element string must follow the GAMS rules for unique elements e.g. not exceeding 63 characters in length and not mixing single- and double-quotes.  </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KeyStr</td><td>The index for this element using strings for the unique elements. One entry for each symbol dimension. </td></tr>
    <tr><td class="paramname">Values</td><td>The values for this element (level, marginal, lower-, upper-bound, scale). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><ul>
<li>
This write operation affects the in-memory GDX object.  </li>
<li>
Actual flushing of the records to the GDX file happens in gdxDataWriteDone.  </li>
<li>
KeyStr should point to one string for each symbol dimension.  </li>
<li>
Each key string should not be longer than 63 characters. Values should be big enough to store 5 double values.  </li>
<li>
Make sure there is a key string for each symbol dimension and each key string does not exceed 63 characters.  </li>
<li>
Make sure values does not contain more than 5 entries.  <b> See: </b> <a href="#gdxDataWriteMapStart">gdxDataWriteMapStart </a> , <a href="#gdxDataWriteDone">gdxDataWriteDone </a></li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>

</div>
</div>
<a id="a638d737c0364437390d5ffc731b31066" name="a638d737c0364437390d5ffc731b31066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638d737c0364437390d5ffc731b31066">&#9670;&#160;</a></span>gdxDataWriteStrStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxDataWriteStrStart </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>SyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ExplTxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Dimen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Typ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UserInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start writing a new symbol in string mode. Returns zero if the operation is not possible or failed. </p>
<p >Adds a new symbol and supplies the UEL keys of the records for each dimension as strings. UEL labels can be known or new (in which case they are added to the UEL table). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyId</td><td>Name of the symbol (limited to 63 characters). The first character of a symbol must be a letter. Following symbol characters may be letters, digits, and underscores. Symbol names must be new and unique. </td></tr>
    <tr><td class="paramname">ExplTxt</td><td>Explanatory text for the symbol (limited to 255 characters). Mixed quote characters will be unified to first occurring one. </td></tr>
    <tr><td class="paramname">Dimen</td><td>Dimension of the symbol (limited to 20). </td></tr>
    <tr><td class="paramname">Typ</td><td>Type of the symbol (set=0, parameter=1, variable=2, equation=3, alias=4). </td></tr>
    <tr><td class="paramname">UserInfo</td><td>Supply additional data. See gdxDataWriteRawStart for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a1fdceb4091918007f4a4ca7819a43c20" title="Write a data element in string mode. Each element string must follow the GAMS rules for unique elemen...">gdxDataWriteStr</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a7f86b31fb404c071ada8b5a2c8e47bdf" title="Finish a write operation. Returns zero if the operation is not possible.">gdxDataWriteDone</a> </dd></dl>

</div>
</div>
<a id="ae3d45de882c24b8d2acdd47417bfc561" name="ae3d45de882c24b8d2acdd47417bfc561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d45de882c24b8d2acdd47417bfc561">&#9670;&#160;</a></span>gdxErrorCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxErrorCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of errors. </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of errors encountered. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a35273506e085ef6d885f94724ca02b86" title="Returns the last error number or zero if there was no error. Calling this function will clear the las...">gdxGetLastError</a> </dd></dl>

</div>
</div>
<a id="a02cfa59bcabe31a143079f5dbd1fd3d6" name="a02cfa59bcabe31a143079f5dbd1fd3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cfa59bcabe31a143079f5dbd1fd3d6">&#9670;&#160;</a></span>gdxErrorStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxErrorStr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ErrNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ErrMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the text for a given error number. Always non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ErrNr</td><td>Error number. </td></tr>
    <tr><td class="paramname">ErrMsg</td><td>Error message (output argument). Contains error text after return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Supplied buffer for error message ErrMsg should be at least 256 bytes long. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns non-zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a35273506e085ef6d885f94724ca02b86" title="Returns the last error number or zero if there was no error. Calling this function will clear the las...">gdxGetLastError</a> </dd></dl>

</div>
</div>
<a id="aed2e8aa58d63ae1d7b7f89b517280355" name="aed2e8aa58d63ae1d7b7f89b517280355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2e8aa58d63ae1d7b7f89b517280355">&#9670;&#160;</a></span>gdxFileInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxFileInfo </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>FileVer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ComprLev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns file format number and compression level used. Always non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileVer</td><td>File format number or zero if the file is not open. </td></tr>
    <tr><td class="paramname">ComprLev</td><td>Compression used; 0= no compression, 1=zlib. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns non-zero. </dd></dl>

</div>
</div>
<a id="a76137ca3e23d4e34e0cce16ffb34845a" name="a76137ca3e23d4e34e0cce16ffb34845a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76137ca3e23d4e34e0cce16ffb34845a">&#9670;&#160;</a></span>gdxFileVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxFileVersion </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>FileStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ProduceStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return strings for file version and file producer. Always non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileStr</td><td>Version string (out argument). Known versions are V5, V6U, V6C and V7. </td></tr>
    <tr><td class="paramname">ProduceStr</td><td>Producer string (out argument). The producer is the application that wrote the GDX file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Supplied buffers for FileStr and ProduceStr should be 256 bytes long to prevent overflow. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Always non-zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#ae53f311244734378f4de7c9c7eafdf67" title="Open a new GDX file for output. Non-zero if the file can be opened, zero otherwise.">gdxOpenWrite</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a3a1538da866ff406cc50477f6bcdc63c" title="Create a GDX file for writing with explicitly given compression flag. Non-zero if the file can be ope...">gdxOpenWriteEx</a> </dd></dl>

</div>
</div>
<a id="aba34d285a642dcc849a40ec08846b714" name="aba34d285a642dcc849a40ec08846b714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba34d285a642dcc849a40ec08846b714">&#9670;&#160;</a></span>gdxFilterExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxFilterExists </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>FilterNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is a filter defined based on its number as used in gdxFilterRegisterStart. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FilterNr</td><td>Filter number as used in FilterRegisterStart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a26dfa9d52a679851a308d58636e836b4" title="Define a unique element filter. Returns zero if the operation is not possible.">gdxFilterRegisterStart</a> </dd></dl>

</div>
</div>
<a id="aa16fefc5481c2fb90b9632e463376404" name="aa16fefc5481c2fb90b9632e463376404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16fefc5481c2fb90b9632e463376404">&#9670;&#160;</a></span>gdxFilterRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxFilterRegister </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UelMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a unique element to the current filter definition, zero if the index number is out of range or was never mapped into the user index space. </p>
<p >Register a unique element as part of the current filter. The function returns false if the index number is out of range of valid user indices or the index was never mapped into the user index space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UelMap</td><td>Unique element number in the user index space or -1 if element was never mapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a26dfa9d52a679851a308d58636e836b4" title="Define a unique element filter. Returns zero if the operation is not possible.">gdxFilterRegisterStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ab4a6c8f8d316d535ae7257bad7134e06" title="Finish registration of unique elements for a filter. Returns zero if the operation is not possible.">gdxFilterRegisterDone</a> </dd></dl>

</div>
</div>
<a id="ab4a6c8f8d316d535ae7257bad7134e06" name="ab4a6c8f8d316d535ae7257bad7134e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a6c8f8d316d535ae7257bad7134e06">&#9670;&#160;</a></span>gdxFilterRegisterDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxFilterRegisterDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish registration of unique elements for a filter. Returns zero if the operation is not possible. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a26dfa9d52a679851a308d58636e836b4" title="Define a unique element filter. Returns zero if the operation is not possible.">gdxFilterRegisterStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aa16fefc5481c2fb90b9632e463376404" title="Add a unique element to the current filter definition, zero if the index number is out of range or wa...">gdxFilterRegister</a> </dd></dl>

</div>
</div>
<a id="a26dfa9d52a679851a308d58636e836b4" name="a26dfa9d52a679851a308d58636e836b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dfa9d52a679851a308d58636e836b4">&#9670;&#160;</a></span>gdxFilterRegisterStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxFilterRegisterStart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>FilterNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a unique element filter. Returns zero if the operation is not possible. </p>
<p >Start the registration of a filter. A filter is used to map a number of elements to a single integer; the filter number. A filter number can later be used to specify a filter for an index position when reading data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FilterNr</td><td>Filter number to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aa16fefc5481c2fb90b9632e463376404" title="Add a unique element to the current filter definition, zero if the index number is out of range or wa...">gdxFilterRegister</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ab4a6c8f8d316d535ae7257bad7134e06" title="Finish registration of unique elements for a filter. Returns zero if the operation is not possible.">gdxFilterRegisterDone</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a0c9314cf277f2e61c7f3c2301cdfe54f" title="Initialize the reading of a symbol in filtered mode. Returns zero if the operation is not possible.">gdxDataReadFilteredStart</a> </dd></dl>

</div>
</div>
<a id="abf4156f064b906dbf1052d39ceb2f6b9" name="abf4156f064b906dbf1052d39ceb2f6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4156f064b906dbf1052d39ceb2f6b9">&#9670;&#160;</a></span>gdxFindSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxFindSymbol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>SyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>SyNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a symbol by name in the symbol table; the search is not case-sensitive. </p>
<ul>
<li>
When the symbol is found, SyNr contains the symbol number and the function returns a non-zero integer.  </li>
<li>
When the symbol is not found, the function returns zero and SyNr is set to -1.  </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyId</td><td>Name of the symbol (must not exceed 63 characters). </td></tr>
    <tr><td class="paramname">SyNr</td><td>Symbol number (&gt;=1 if exists, 0 for universe and -1 if not found). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the symbol is found, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a8f6f6ffff7ed12a048c8d4afcbe106fd" title="Returns information (name, dimension count, type) about a symbol from the symbol table....">gdxSymbolInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#adf3c2e34e519e2f68e7ff57966bce35e" title="Returns additional information about a symbol. Returns zero if the symbol number is out of range,...">gdxSymbolInfoX</a> </dd></dl>

</div>
</div>
<a id="a29e38caa19cf9afd559432abd76f9868" name="a29e38caa19cf9afd559432abd76f9868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e38caa19cf9afd559432abd76f9868">&#9670;&#160;</a></span>gdxGetDLLVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxGetDLLVersion </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a version descriptor of the library. Always non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Contains version string after return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Output argument buffer V should be 256 bytes long. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns non-zero. </dd></dl>

</div>
</div>
<a id="a44fec2813995c0fa49b83a0838faf4ff" name="a44fec2813995c0fa49b83a0838faf4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fec2813995c0fa49b83a0838faf4ff">&#9670;&#160;</a></span>gdxGetDomainElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxGetDomainElements </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>DimPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>FilterNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDomainIndexProc_t&#160;</td>
          <td class="paramname"><em>DP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>NrElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Uptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique elements for a given dimension of a given symbol. </p>
<p >Using the data of a symbol, get the unique elements for a given index position. To achieve this, the symbols data is read and a tally is kept for the elements in the given index position. When a filter is specified, records that have elements in the specified index position that are outside the filter will be added to the list of DataErrorRecords. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol, range 1..NrSymbols; SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">DimPos</td><td>The dimension to use, range 1..dim. </td></tr>
    <tr><td class="paramname">FilterNr</td><td>Number of a previously registered filter or the value DOMC_EXPAND if no filter is wanted. </td></tr>
    <tr><td class="paramname">DP</td><td>Callback procedure which will be called once for each available element (can be nil). </td></tr>
    <tr><td class="paramname">NrElem</td><td>Number of unique elements found. </td></tr>
    <tr><td class="paramname">Uptr</td><td>User pointer; will be passed to the callback procedure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. <div class="fragment"><div class="line"><span class="keywordtype">int</span> Cnt;</div>
<div class="line"><span class="keyword">auto</span> DataDomainCB = [](<span class="keywordtype">int</span> RawNr, <span class="keywordtype">int</span> MappedNr, <span class="keywordtype">void</span> *UPtr) {</div>
<div class="line">    std::cout &lt;&lt; RawNr &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; MappedNr &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">};</div>
<div class="line">pgx.gdxGetDomainElements(1, 1, DOMC_EXPAND, <span class="keyword">nullptr</span>, cnt);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Domain count only = &quot;</span> &lt;&lt; cnt &lt;&lt; std::endl;</div>
<div class="line">pgx.gdxGetDomainElements(1, 1, DOMC_EXPAND, DataDomainCB, cnt);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Get domain count = &quot;</span> &lt;&lt; cnt &lt;&lt; std::endl;</div>
<div class="line">pgx.gdxGetDomainElements(1, 1, 7, DataDomainCB, cnt);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Using filter 7; number of records in error list = &quot;</span> &lt;&lt; <a class="code hl_function" href="classgdx_1_1TGXFileObj.html#aaae21ed2293db76cdbd05dd06a94a775">gdxDataErrorCount</a>(PGX) &lt;&lt; std::endl;</div>
<div class="ttc" id="aclassgdx_1_1TGXFileObj_html_aaae21ed2293db76cdbd05dd06a94a775"><div class="ttname"><a href="classgdx_1_1TGXFileObj.html#aaae21ed2293db76cdbd05dd06a94a775">gdx::TGXFileObj::gdxDataErrorCount</a></div><div class="ttdeci">int gdxDataErrorCount() const</div><div class="ttdoc">Query the number of error records.</div><div class="ttdef"><b>Definition:</b> gxfile.cpp:2131</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a36c5e9b87188458bfca1d08e4595f4d7" title="Retrieve an error record. Non-zero if the record number is valid.">gdxDataErrorRecord</a> </dd></dl>

</div>
</div>
<a id="ada63dd0c8f185c863b19bd39304318d5" name="ada63dd0c8f185c863b19bd39304318d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada63dd0c8f185c863b19bd39304318d5">&#9670;&#160;</a></span>gdxGetElemText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxGetElemText </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>TxtNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the string and node number for an entry in the string table. Returns zero if the operation is not possible. </p>
<ul>
<li>
When writing to a GDX file, this index is the value returned by calling gdxAddSetText.  </li>
<li>
When reading a GDX file, the index is returned as the level value when reading a set.  </li>
</ul>
<p>The Node number can be used as an index in a string table in the user space; the value is set by calling SetTextNodeNr. <br  />
 If the Node number was never assigned, it will be returned as zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TxtNr</td><td>String table index. </td></tr>
    <tr><td class="paramname">Txt</td><td>Text found for the entry. Buffer should be 256 bytes wide. </td></tr>
    <tr><td class="paramname">Node</td><td>Node number (user space) found for the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Buffer supplied in out argument string Txt should be 256 bytes wide to prevent overflow! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. <div class="fragment"><div class="line"><span class="comment">// assumes we are reading using strings</span></div>
<div class="line"><span class="keywordflow">while</span>(pgx.gdxDataReadStr(Uels, Vals)) {</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> D{}; D&lt;Dim; D++)</div>
<div class="line">      std::cout &lt;&lt; Uels[D] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">   <span class="keywordtype">int</span> indx = std::round(Vals[vallevel]);</div>
<div class="line">   <span class="keywordflow">if</span>(indx &gt; 0) {</div>
<div class="line">      pgx.gdxGetElemText(indx, S, N);</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;txt = &quot;</span> &lt;&lt; S &lt;&lt; <span class="stringliteral">&quot;Node = &quot;</span> &lt;&lt; N;</div>
<div class="line">   }</div>
<div class="line">   std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a1a35f810ade409dc201291bdb28c4ab2" title="Register a string in the string table Register a string in the string table and return the integer nu...">gdxAddSetText</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a2e17521127e04fb89454b49521c9be22" title="Set the Node number for an entry in the string table. After registering a string with AddSetText,...">gdxSetTextNodeNr</a> </dd></dl>

</div>
</div>
<a id="a35273506e085ef6d885f94724ca02b86" name="a35273506e085ef6d885f94724ca02b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35273506e085ef6d885f94724ca02b86">&#9670;&#160;</a></span>gdxGetLastError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxGetLastError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last error number or zero if there was no error. Calling this function will clear the last error stored. </p>
<p >When an error is encountered, an error code is stored which can be retrieved with this function. If subsequent errors occur before this function is called, the first error code will be maintained. Calling this function will clear the last error stored. </p><dl class="section return"><dt>Returns</dt><dd>The error number, or zero if there was no error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#ae3d45de882c24b8d2acdd47417bfc561" title="Returns the number of errors.">gdxErrorCount</a> </dd></dl>

</div>
</div>
<a id="a2a18dada36a25f6ea5391d5b263bc173" name="a2a18dada36a25f6ea5391d5b263bc173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a18dada36a25f6ea5391d5b263bc173">&#9670;&#160;</a></span>gdxGetMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t gdx::TGXFileObj::gdxGetMemoryUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes used by the data objects. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes used by the data objects. </dd></dl>

</div>
</div>
<a id="ac3eee784b7fe5b800699a510eadc9ce5" name="ac3eee784b7fe5b800699a510eadc9ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3eee784b7fe5b800699a510eadc9ce5">&#9670;&#160;</a></span>gdxGetSpecialValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxGetSpecialValues </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>AVals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the internal values for special values. Always non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AVals</td><td>6-element array of special values used for Undef (0), NA (1), +Inf (2), -Inf (3), Eps (4), Acronym (6). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Output argument array Avals should have size for 7 elements. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Always non-zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a6d37f601cb0b974081d0ca4c899c0f7f" title="Reset the internal values for special values. Always non-zero.">gdxResetSpecialValues</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aaa2598f7b7a88909edb367ae931dbda1" title="Set the internal values for special values. Before calling this function, initialize the array of spe...">gdxSetSpecialValues</a> </dd></dl>

</div>
</div>
<a id="ace4928e7d18a0365c3c0af5aa7f0c65a" name="ace4928e7d18a0365c3c0af5aa7f0c65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4928e7d18a0365c3c0af5aa7f0c65a">&#9670;&#160;</a></span>gdxGetUEL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxGetUEL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UelNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Uel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string for a unique element using a mapped index. Returns zero if the operation is not possible. </p>
<p >Retrieve the string for an unique element based on a mapped index number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UelNr</td><td>Index number in user space (range 1..NrUserElem). </td></tr>
    <tr><td class="paramname">Uel</td><td>String for the unique element which may be up to 63 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Supplied buffer for storing the Uel name should be 64 bytes long to prevent overflow! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Return non-zero if the index is in a valid range, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a8aa4bee81394262223a74e7283daa0f0" title="Get a unique element using an unmapped index. Returns zero if the operation is not possible.">gdxUMUelGet</a> </dd></dl>

</div>
</div>
<a id="a22a8f3d3aa5d41615ecb4e41d64c9669" name="a22a8f3d3aa5d41615ecb4e41d64c9669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a8f3d3aa5d41615ecb4e41d64c9669">&#9670;&#160;</a></span>gdxMapAcronymsToNaN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxMapAcronymsToNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag to map all acronym values to the GAMS "Not a Number" special value. Disabled by default. </p>
<dl class="section return"><dt>Returns</dt><dd>1 (true) iff. flag is set, 0 (false) otherwise. </dd></dl>

</div>
</div>
<a id="af2d766eb279da81358bba0496a1dc35f" name="af2d766eb279da81358bba0496a1dc35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d766eb279da81358bba0496a1dc35f">&#9670;&#160;</a></span>gdxMapAcronymsToNaNSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gdx::TGXFileObj::gdxMapAcronymsToNaNSet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag to map all acronym values to the GAMS "Not a Number" special value. Disabled by default. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>1 (true) to enable and 0 (false) to disable flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4316f65e6f0c68c3ca6f0a32671ea823" name="a4316f65e6f0c68c3ca6f0a32671ea823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4316f65e6f0c68c3ca6f0a32671ea823">&#9670;&#160;</a></span>gdxMapValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxMapValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Classify a value as a potential special value. Non-zero if D is a special value, zero otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Value to classify. </td></tr>
    <tr><td class="paramname">sv</td><td>Classification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero if D is a special value, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#ac3eee784b7fe5b800699a510eadc9ce5" title="Retrieve the internal values for special values. Always non-zero.">gdxGetSpecialValues</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aaa2598f7b7a88909edb367ae931dbda1" title="Set the internal values for special values. Before calling this function, initialize the array of spe...">gdxSetSpecialValues</a> </dd></dl>

</div>
</div>
<a id="a52f09635e83e11b65dcfdcbd617f0600" name="a52f09635e83e11b65dcfdcbd617f0600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f09635e83e11b65dcfdcbd617f0600">&#9670;&#160;</a></span>gdxOpenAppend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxOpenAppend </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>FileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ErrNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an existing GDX file for output. Non-zero if the file can be opened, zero otherwise. </p>
<p >If a file extension is not supplied, the extension ''.gdx'' will be used. The return code is a system dependent I/O error. When appending to a GDX file, the symbol table, uel table etc will be read and the whole setup will be treated as if all symbols were just written to the GDX file. Replacing a symbol is not allowed; it will generate a duplicate symbol error. ' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>File name of the GDX file to be created (arbitrary length). </td></tr>
    <tr><td class="paramname">Producer</td><td>Name of program that appends to the GDX file (should not exceed 255 characters). </td></tr>
    <tr><td class="paramname">ErrNr</td><td>Returns an error code or zero if there is no error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero if the file can be opened; zero otherwise. <div class="fragment"><div class="line">std::string Msg;</div>
<div class="line"><a class="code hl_class" href="classgdx_1_1TGXFileObj.html">TGXFileObj</a> pgx {Msg}</div>
<div class="line"><span class="keywordtype">int</span> ErrCode;</div>
<div class="line">pgx.<a class="code hl_function" href="classgdx_1_1TGXFileObj.html#a52f09635e83e11b65dcfdcbd617f0600">gdxOpenAppend</a>(<span class="stringliteral">&quot;file1.gdx&quot;</span>,<span class="stringliteral">&quot;Examples&quot;</span>, ErrCode);</div>
<div class="line"><span class="keywordflow">if</span>(ErrCode) {</div>
<div class="line">  [ ... ]</div>
<div class="line">}</div>
<div class="ttc" id="aclassgdx_1_1TGXFileObj_html_a52f09635e83e11b65dcfdcbd617f0600"><div class="ttname"><a href="classgdx_1_1TGXFileObj.html#a52f09635e83e11b65dcfdcbd617f0600">gdx::TGXFileObj::gdxOpenAppend</a></div><div class="ttdeci">int gdxOpenAppend(const char *FileName, const char *Producer, int &amp;ErrNr)</div><div class="ttdoc">Open an existing GDX file for output. Non-zero if the file can be opened, zero otherwise.</div><div class="ttdef"><b>Definition:</b> gxfile.cpp:3409</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a4a3b3e0ffdf3bbb17070e43ba7e98408" title="Open a GDX file for reading. Non-zero if the file can be opened, zero otherwise.">gdxOpenRead</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ae53f311244734378f4de7c9c7eafdf67" title="Open a new GDX file for output. Non-zero if the file can be opened, zero otherwise.">gdxOpenWrite</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a3a1538da866ff406cc50477f6bcdc63c" title="Create a GDX file for writing with explicitly given compression flag. Non-zero if the file can be ope...">gdxOpenWriteEx</a> </dd></dl>

</div>
</div>
<a id="a4a3b3e0ffdf3bbb17070e43ba7e98408" name="a4a3b3e0ffdf3bbb17070e43ba7e98408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3b3e0ffdf3bbb17070e43ba7e98408">&#9670;&#160;</a></span>gdxOpenRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxOpenRead </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>FileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ErrNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a GDX file for reading. Non-zero if the file can be opened, zero otherwise. </p>
<p >Open an existing GDX file for input. If a file extension is not supplied, the extension '.gdx' will be used. The return code is a system dependent I/O error. If the file was found, but is not a valid GDX file, the function GetLastError can be used to handle these type of errors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>File name of the GDX file to be opened (arbitrary length). </td></tr>
    <tr><td class="paramname">ErrNr</td><td>Returns an error code or zero if there is no error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero if the file can be opened; zero otherwise. <div class="fragment"><div class="line">std::string errMsg;</div>
<div class="line"><a class="code hl_class" href="classgdx_1_1TGXFileObj.html">TGXFileObj</a> pgx{errMsg};</div>
<div class="line">pgx.<a class="code hl_function" href="classgdx_1_1TGXFileObj.html#a4a3b3e0ffdf3bbb17070e43ba7e98408">gdxOpenRead</a>(<span class="stringliteral">&quot;file1.gdx&quot;</span>, ErrNr);</div>
<div class="line"><span class="keywordflow">if</span>(ErrNr) {</div>
<div class="line">  [...]</div>
<div class="line">}</div>
<div class="ttc" id="aclassgdx_1_1TGXFileObj_html_a4a3b3e0ffdf3bbb17070e43ba7e98408"><div class="ttname"><a href="classgdx_1_1TGXFileObj.html#a4a3b3e0ffdf3bbb17070e43ba7e98408">gdx::TGXFileObj::gdxOpenRead</a></div><div class="ttdeci">int gdxOpenRead(const char *FileName, int &amp;ErrNr)</div><div class="ttdoc">Open a GDX file for reading. Non-zero if the file can be opened, zero otherwise.</div><div class="ttdef"><b>Definition:</b> gxfile.cpp:1718</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#ae53f311244734378f4de7c9c7eafdf67" title="Open a new GDX file for output. Non-zero if the file can be opened, zero otherwise.">gdxOpenWrite</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a35273506e085ef6d885f94724ca02b86" title="Returns the last error number or zero if there was no error. Calling this function will clear the las...">gdxGetLastError</a> </dd></dl>

</div>
</div>
<a id="a0a68a1f9f4bed4dcf87ec54b9938f6e2" name="a0a68a1f9f4bed4dcf87ec54b9938f6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a68a1f9f4bed4dcf87ec54b9938f6e2">&#9670;&#160;</a></span>gdxOpenReadEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxOpenReadEx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>FileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ReadMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ErrNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a GDX file for reading allowing for skipping sections. Non-zero if the file can be opened, zero otherwise. </p>
<p >Open an existing GDX file for input. If a file extension is not supplied, the extension '.gdx' will be used. The return code is a system dependent I/O error. If the file was found, but is not a valid GDX file, the function GetLastError can be used to handle these type of errors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>File name of the GDX file to be opened (arbitrary length). </td></tr>
    <tr><td class="paramname">ReadMode</td><td>Bitmap skip reading sections: 0-bit: string (1 skip reading string). </td></tr>
    <tr><td class="paramname">ErrNr</td><td>Returns an error code or zero if there is no error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero if the file can be opened; zero otherwise. <div class="fragment"><div class="line"><span class="keywordtype">int</span> ErrNr;</div>
<div class="line">pgx.gdxOpenReadEx(<span class="stringliteral">&quot;file1.gdx&quot;</span>, fmOpenRead, ErrNr);</div>
<div class="line"><span class="keywordflow">if</span>(ErrNr) {</div>
<div class="line">   [...]</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#ae53f311244734378f4de7c9c7eafdf67" title="Open a new GDX file for output. Non-zero if the file can be opened, zero otherwise.">gdxOpenWrite</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a35273506e085ef6d885f94724ca02b86" title="Returns the last error number or zero if there was no error. Calling this function will clear the las...">gdxGetLastError</a> </dd></dl>

</div>
</div>
<a id="ae53f311244734378f4de7c9c7eafdf67" name="ae53f311244734378f4de7c9c7eafdf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53f311244734378f4de7c9c7eafdf67">&#9670;&#160;</a></span>gdxOpenWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxOpenWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>FileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ErrNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a new GDX file for output. Non-zero if the file can be opened, zero otherwise. </p>
<p >Uses the environment variable GDXCOMPRESS to set compression argument for gdxOpenWriteEx. Potentially overwrites existing file with same name. If a file extension is not supplied, the extension '.gdx' will be used. The return code is a system dependent I/O error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>File name of the GDX file to be created with arbitrary length. </td></tr>
    <tr><td class="paramname">Producer</td><td>Name of program that creates the GDX file (should not exceed 255 characters). </td></tr>
    <tr><td class="paramname">ErrNr</td><td>Returns an error code or zero if there is no error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero if the file can be opened; zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a4a3b3e0ffdf3bbb17070e43ba7e98408" title="Open a GDX file for reading. Non-zero if the file can be opened, zero otherwise.">gdxOpenRead</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a3a1538da866ff406cc50477f6bcdc63c" title="Create a GDX file for writing with explicitly given compression flag. Non-zero if the file can be ope...">gdxOpenWriteEx</a> </dd></dl>

</div>
</div>
<a id="a3a1538da866ff406cc50477f6bcdc63c" name="a3a1538da866ff406cc50477f6bcdc63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1538da866ff406cc50477f6bcdc63c">&#9670;&#160;</a></span>gdxOpenWriteEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxOpenWriteEx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>FileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Compr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ErrNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a GDX file for writing with explicitly given compression flag. Non-zero if the file can be opened, zero otherwise. </p>
<p >Open a new GDX file for output. If a file extension is not supplied, the extension '.gdx' will be used. The return code is a system dependent I/O error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>File name of the GDX file to be created with arbitrary length. </td></tr>
    <tr><td class="paramname">Producer</td><td>Name of program that creates the GDX file (should not exceed 255 characters). </td></tr>
    <tr><td class="paramname">Compr</td><td>Zero for no compression; non-zero uses compression (if available). </td></tr>
    <tr><td class="paramname">ErrNr</td><td>Returns an error code or zero if there is no error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>When writing compressed, set the AutoConvert flag to zero so the file is not uncompressed after the gdxClose; see gdxAutoConvert. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero if the file can be opened; zero otherwise. <div class="fragment"><div class="line">std::string errMsg;</div>
<div class="line"><a class="code hl_class" href="classgdx_1_1TGXFileObj.html">TGXFileObj</a> pgx{errMsg};</div>
<div class="line"><span class="keywordflow">if</span>(!errMsg.empty()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Failure with GDX: &quot;</span> &lt;&lt; errMsg &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> ErrCode;</div>
<div class="line">pgx.<a class="code hl_function" href="classgdx_1_1TGXFileObj.html#a3a1538da866ff406cc50477f6bcdc63c">gdxOpenWriteEx</a>(<span class="stringliteral">&quot;file1.gdx&quot;</span>, <span class="stringliteral">&quot;Examples&quot;</span>, 1, ErrCode);</div>
<div class="line">pgx.gdxAutoConvert(0);</div>
<div class="line"><span class="keywordflow">if</span>(ErrCode) {</div>
<div class="line">[ ... ]</div>
<div class="line">}</div>
<div class="ttc" id="aclassgdx_1_1TGXFileObj_html_a3a1538da866ff406cc50477f6bcdc63c"><div class="ttname"><a href="classgdx_1_1TGXFileObj.html#a3a1538da866ff406cc50477f6bcdc63c">gdx::TGXFileObj::gdxOpenWriteEx</a></div><div class="ttdeci">int gdxOpenWriteEx(const char *FileName, const char *Producer, int Compr, int &amp;ErrNr)</div><div class="ttdoc">Create a GDX file for writing with explicitly given compression flag. Non-zero if the file can be ope...</div><div class="ttdef"><b>Definition:</b> gxfile.cpp:394</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a4a3b3e0ffdf3bbb17070e43ba7e98408" title="Open a GDX file for reading. Non-zero if the file can be opened, zero otherwise.">gdxOpenRead</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ae53f311244734378f4de7c9c7eafdf67" title="Open a new GDX file for output. Non-zero if the file can be opened, zero otherwise.">gdxOpenWrite</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ae0b2458fa7062edde0eedde8fc5ec40a" title="Returns the value of the AutoConvert variable and sets the variable to nv. When we close a new GDX fi...">gdxAutoConvert</a> </dd></dl>

</div>
</div>
<a id="a36a4e636ae4d3e85b042c9a4b92fa075" name="a36a4e636ae4d3e85b042c9a4b92fa075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a4e636ae4d3e85b042c9a4b92fa075">&#9670;&#160;</a></span>gdxRenameUEL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxRenameUEL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>OldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>NewName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename unique element OldName to NewName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OldName</td><td>Name of an existing unique element (UEL). </td></tr>
    <tr><td class="paramname">NewName</td><td>New name for the UEL. Must not exist in UEL table yet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>String for unique element (UEL) which may not exceed a length of 63 characters. Furthermore a UEL string must not mix single- and double-quotes. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the renaming was possible; non-zero is an error indicator. </dd></dl>

</div>
</div>
<a id="a6d37f601cb0b974081d0ca4c899c0f7f" name="a6d37f601cb0b974081d0ca4c899c0f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d37f601cb0b974081d0ca4c899c0f7f">&#9670;&#160;</a></span>gdxResetSpecialValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxResetSpecialValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the internal values for special values. Always non-zero. </p>
<dl class="section return"><dt>Returns</dt><dd>Always non-zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aaa2598f7b7a88909edb367ae931dbda1" title="Set the internal values for special values. Before calling this function, initialize the array of spe...">gdxSetSpecialValues</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ac3eee784b7fe5b800699a510eadc9ce5" title="Retrieve the internal values for special values. Always non-zero.">gdxGetSpecialValues</a> </dd></dl>

</div>
</div>
<a id="ae3758f05c24a9cd2f777873a49e697ea" name="ae3758f05c24a9cd2f777873a49e697ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3758f05c24a9cd2f777873a49e697ea">&#9670;&#160;</a></span>gdxSetHasText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSetHasText </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if any of the elements of the set has an associated text. Non-zero if the Set contains at least one unique element that has associated text, zero otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>Set symbol number (range 1..NrSymbols); SyNr = 0 reads universe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the set contains at least one element that has associated text, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a96fccb045a2f3eab80d4b091c8224376" title="Returns the number of symbols and unique elements. Always non-zero.">gdxSystemInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a8f6f6ffff7ed12a048c8d4afcbe106fd" title="Returns information (name, dimension count, type) about a symbol from the symbol table....">gdxSymbolInfo</a> </dd></dl>

</div>
</div>
<a id="ac01fdf317cb96c6a94a3e53bd3b052ff" name="ac01fdf317cb96c6a94a3e53bd3b052ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01fdf317cb96c6a94a3e53bd3b052ff">&#9670;&#160;</a></span>gdxSetReadSpecialValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSetReadSpecialValues </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>AVals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal values for special values when reading a GDX file. Before calling this function, initialize the array of special values by calling gdxGetSpecialValues first. Always non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AVals</td><td>5-element array of special values to be used for Undef, NA, +Inf, -Inf, and Eps. Note that the values do not have to be unique. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Before calling this function, initialize the array of special values by calling gdxGetSpecialValues first. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>AVals must have length of at least 5 double values. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Always non-zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#aaa2598f7b7a88909edb367ae931dbda1" title="Set the internal values for special values. Before calling this function, initialize the array of spe...">gdxSetSpecialValues</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a6d37f601cb0b974081d0ca4c899c0f7f" title="Reset the internal values for special values. Always non-zero.">gdxResetSpecialValues</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ac3eee784b7fe5b800699a510eadc9ce5" title="Retrieve the internal values for special values. Always non-zero.">gdxGetSpecialValues</a> </dd></dl>

</div>
</div>
<a id="aaa2598f7b7a88909edb367ae931dbda1" name="aaa2598f7b7a88909edb367ae931dbda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2598f7b7a88909edb367ae931dbda1">&#9670;&#160;</a></span>gdxSetSpecialValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSetSpecialValues </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>AVals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal values for special values. Before calling this function, initialize the array of special values by calling gdxGetSpecialValues first. Note, values in AVals have to be unique. Non- zero if all values specified are unique, zero otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AVals</td><td>Array of special values to be used Undef (0), NA (1), +Inf (2), -Inf (3), and EPS (4). Note that the values have to be unique and AVals should have length 7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Before calling this function, initialize the array of special values by calling gdxGetSpecialValues first. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Size of AVals should be 7. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if all values specified are unique, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#ac01fdf317cb96c6a94a3e53bd3b052ff" title="Set the internal values for special values when reading a GDX file. Before calling this function,...">gdxSetReadSpecialValues</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a6d37f601cb0b974081d0ca4c899c0f7f" title="Reset the internal values for special values. Always non-zero.">gdxResetSpecialValues</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ac3eee784b7fe5b800699a510eadc9ce5" title="Retrieve the internal values for special values. Always non-zero.">gdxGetSpecialValues</a> </dd></dl>

</div>
</div>
<a id="a2e17521127e04fb89454b49521c9be22" name="a2e17521127e04fb89454b49521c9be22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e17521127e04fb89454b49521c9be22">&#9670;&#160;</a></span>gdxSetTextNodeNr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSetTextNodeNr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>TxtNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Node number for an entry in the string table. After registering a string with AddSetText, we can assign a node number for later retrieval. Returns zero if the operation is not possible. </p>
<p >After registering a string with AddSetText, we can assign a node number for later retrieval. The node number is any integer which is stored without further restrictions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TxtNr</td><td>Index number of the entry to be modified. </td></tr>
    <tr><td class="paramname">Node</td><td>The new Node value for the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a1a35f810ade409dc201291bdb28c4ab2" title="Register a string in the string table Register a string in the string table and return the integer nu...">gdxAddSetText</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ada63dd0c8f185c863b19bd39304318d5" title="Retrieve the string and node number for an entry in the string table. Returns zero if the operation i...">gdxGetElemText</a> </dd></dl>

</div>
</div>
<a id="a18f40d7fd17618c9416464a480efc37b" name="a18f40d7fd17618c9416464a480efc37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f40d7fd17618c9416464a480efc37b">&#9670;&#160;</a></span>gdxSetTraceLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSetTraceLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the amount of trace (debug) information generated. Always non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Tracing level N &lt;= 0 no tracing N &gt;= 3 maximum tracing. </td></tr>
    <tr><td class="paramname">s</td><td>A string to be included in the trace output (arbitrary length). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always non-zero. </dd></dl>
<p >! GetStdHandle(STD_OUTPUT_HANDLE) &lt;&gt; INVALID_HANDLE_VALUE;</p>

</div>
</div>
<a id="a5290760aefaf9af4ab092d68fd187642" name="a5290760aefaf9af4ab092d68fd187642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5290760aefaf9af4ab092d68fd187642">&#9670;&#160;</a></span>gdxStoreDomainSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxStoreDomainSets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flag to store one dimensional sets as potential domains, false (0) saves lots of space for large 1-dim sets that are no domains but can create inconsistent GDX files if used incorrectly. Returns 1 (true) iff. elements of 1-dim sets should be tracked for domain checking, 0 (false) otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>1 (true) iff. flag is set, 0 (false) otherwise. </dd></dl>

</div>
</div>
<a id="a5aa88feb1bb15e035596dbb87e630f0c" name="a5aa88feb1bb15e035596dbb87e630f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa88feb1bb15e035596dbb87e630f0c">&#9670;&#160;</a></span>gdxStoreDomainSetsSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gdx::TGXFileObj::gdxStoreDomainSetsSet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flag to store one dimensional sets as potential domains, false (0) saves lots of space for large 1-dim sets that are no domains but can create inconsistent GDX files if used incorrectly. Param flag 1 (true) iff. elements of 1-dim sets should be tracked for domain checking, 0 (false) otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>1 (true) to enable and 0 (false) to disable flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7de4b7f90ec26e71c54b6e1df1e8595" name="af7de4b7f90ec26e71c54b6e1df1e8595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7de4b7f90ec26e71c54b6e1df1e8595">&#9670;&#160;</a></span>gdxSymbIndxMaxLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbIndxMaxLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>LengthInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the longest UEL used for every index position for a given symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>Symbol number (range 1..NrSymbols); SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">LengthInfo</td><td>The longest length for each index position. This output argument should be able to store one integer for each symbol dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Make sure LengthInfo can store one integer for each symbol dimension. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the longest UEL found in the data (over all dimensions). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a63d3826003c3392656f5fff96140a6db" title="Returns the length of the longest unique element (UEL) name.">gdxUELMaxLength</a> </dd></dl>

</div>
</div>
<a id="ab2ffa7df3ce6a691bc0c41737a012262" name="ab2ffa7df3ce6a691bc0c41737a012262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ffa7df3ce6a691bc0c41737a012262">&#9670;&#160;</a></span>gdxSymbMaxLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbMaxLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the longest symbol name in the GDX file. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of characters in the longest symbol name. </dd></dl>

</div>
</div>
<a id="a0473b4f834a31d23e494ae5b1323f380" name="a0473b4f834a31d23e494ae5b1323f380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0473b4f834a31d23e494ae5b1323f380">&#9670;&#160;</a></span>gdxSymbolAddComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbolAddComment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Txt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a line of comment text for a symbol. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The symbol number (range 1..NrSymbols); if SyNr &lt;= 0 the current symbol being written. </td></tr>
    <tr><td class="paramname">Txt</td><td>String to add which should not exceed a length of 255 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>A line of comment text can not contain more than 255 characters but there are no other restrictions on it. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a0cbad43f6b67e6858a2fc2af9b9b7101" title="Retrieve a line of comment text for a symbol. Returns zero if the operation is not possible.">gdxSymbolGetComment</a> </dd></dl>

</div>
</div>
<a id="a734edcd65d93902112d4bed17ae00edd" name="a734edcd65d93902112d4bed17ae00edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734edcd65d93902112d4bed17ae00edd">&#9670;&#160;</a></span>gdxSymbolDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbolDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns dimensionality of a symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The symbol number (range 0..NrSymbols); return universe info when SyNr = 0.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the symbol number is not in the correct range, the symbol dimension otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a8f6f6ffff7ed12a048c8d4afcbe106fd" title="Returns information (name, dimension count, type) about a symbol from the symbol table....">gdxSymbolInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#adf3c2e34e519e2f68e7ff57966bce35e" title="Returns additional information about a symbol. Returns zero if the symbol number is out of range,...">gdxSymbolInfoX</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#abf4156f064b906dbf1052d39ceb2f6b9" title="Search for a symbol by name in the symbol table; the search is not case-sensitive.">gdxFindSymbol</a> </dd></dl>

</div>
</div>
<a id="a0cbad43f6b67e6858a2fc2af9b9b7101" name="a0cbad43f6b67e6858a2fc2af9b9b7101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbad43f6b67e6858a2fc2af9b9b7101">&#9670;&#160;</a></span>gdxSymbolGetComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbolGetComment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Txt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a line of comment text for a symbol. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The symbol number (range 1..NrSymbols); SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">N</td><td>Line number in the comment block (1..Count). </td></tr>
    <tr><td class="paramname">Txt</td><td>String containing the line requested (empty on error). Buffer should be able to hold 255 characters. Potential causes for empty strings are symbol- (SyNr) or line-number (N) out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Output argument string buffer must have size of 256 bytes. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a0473b4f834a31d23e494ae5b1323f380" title="Add a line of comment text for a symbol. Returns zero if the operation is not possible.">gdxSymbolAddComment</a> </dd></dl>

</div>
</div>
<a id="acf107aae2a6daf07c721f1a2ce8e70a5" name="acf107aae2a6daf07c721f1a2ce8e70a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf107aae2a6daf07c721f1a2ce8e70a5">&#9670;&#160;</a></span>gdxSymbolGetDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbolGetDomain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>DomainSyNrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the domain of a symbol. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol (range 1..NrSymbols); SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">DomainSyNrs</td><td>Array (length=symbol dim) returning the set identifiers or "*"; DomainSyNrs[D] will contain the index number of the one dimensional set or alias used as the domain for index position D. A value of zero represents the universe "*". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Integer array DomainSyNrs should be able to store one entry for each symbol dimension. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a3955eaf00687760c2b7cdce9c9eb9fd7" title="Define the domain of a symbol for which a write data operation just started using DataWriteRawStart,...">gdxSymbolSetDomain</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a2b75bb5610c7bb4c710b0c312074edeb" title="Retrieve the domain of a symbol (using relaxed or domain information). Returns zero if the operation ...">gdxSymbolGetDomainX</a> </dd></dl>

</div>
</div>
<a id="a2b75bb5610c7bb4c710b0c312074edeb" name="a2b75bb5610c7bb4c710b0c312074edeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b75bb5610c7bb4c710b0c312074edeb">&#9670;&#160;</a></span>gdxSymbolGetDomainX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbolGetDomainX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>DomainIDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the domain of a symbol (using relaxed or domain information). Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol (range 1..NrSymbols); SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">DomainIDs</td><td>DomainIDs[D] will contain the strings as they were stored with the call gdxSymbolSetDomainX. If gdxSymbolSetDomainX was never called, but gdxSymbolSetDomain was called, that information will be used instead. Length of this array should by dimensionality of the symbol. The special domain name "*" denotes the universe domain (all known UELs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Make sure DomainIDs is able to store a domain name for each symbol dimension. Each domain name requires a 256 byte wide buffer to store its maximum of 255 characters. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
0: If operation was not possible (Bad SyNr)  </li>
<li>
1: No domain information was available  </li>
<li>
2: Data used was defined using gdxSymbolSetDomainX  </li>
<li>
3: Data used was defined using gdxSymbolSetDomain  </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a39687019d377ad28428f052d49672ac1" title="Define the domain of a symbol (relaxed version). Returns zero if the operation is not possible.">gdxSymbolSetDomainX</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a3955eaf00687760c2b7cdce9c9eb9fd7" title="Define the domain of a symbol for which a write data operation just started using DataWriteRawStart,...">gdxSymbolSetDomain</a> </dd></dl>

</div>
</div>
<a id="a8f6f6ffff7ed12a048c8d4afcbe106fd" name="a8f6f6ffff7ed12a048c8d4afcbe106fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6f6ffff7ed12a048c8d4afcbe106fd">&#9670;&#160;</a></span>gdxSymbolInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbolInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>SyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Dimen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Typ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns information (name, dimension count, type) about a symbol from the symbol table. Returns zero if the symbol number is out of range, non-zero otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The symbol number (range 0..NrSymbols); return universe info () when SyNr = 0. </td></tr>
    <tr><td class="paramname">SyId</td><td>Name of the symbol (buffer should be 64 bytes long). Magic name "*" for universe. </td></tr>
    <tr><td class="paramname">Dimen</td><td>Dimension of the symbol (range 0..20). </td></tr>
    <tr><td class="paramname">Typ</td><td>Symbol type (set=0, parameter=1, variable=2, equation=3, alias=4). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>SyId must be 64 characters long. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the symbol number is not in the correct range, non-zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a96fccb045a2f3eab80d4b091c8224376" title="Returns the number of symbols and unique elements. Always non-zero.">gdxSystemInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#adf3c2e34e519e2f68e7ff57966bce35e" title="Returns additional information about a symbol. Returns zero if the symbol number is out of range,...">gdxSymbolInfoX</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a734edcd65d93902112d4bed17ae00edd" title="Returns dimensionality of a symbol.">gdxSymbolDim</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#abf4156f064b906dbf1052d39ceb2f6b9" title="Search for a symbol by name in the symbol table; the search is not case-sensitive.">gdxFindSymbol</a> </dd></dl>

</div>
</div>
<a id="adf3c2e34e519e2f68e7ff57966bce35e" name="adf3c2e34e519e2f68e7ff57966bce35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3c2e34e519e2f68e7ff57966bce35e">&#9670;&#160;</a></span>gdxSymbolInfoX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbolInfoX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>RecCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UserInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ExplTxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns additional information about a symbol. Returns zero if the symbol number is out of range, non-zero otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The symbol number (range 0..NrSymbols); return universe info when SyNr = 0. </td></tr>
    <tr><td class="paramname">RecCnt</td><td>Total number of records stored (unmapped); for the universe (SyNr = 0) this is the number of entries when the GDX file was opened for reading. </td></tr>
    <tr><td class="paramname">UserInfo</td><td>User field value storing additional data; GAMS follows the following conventions: <table class="doxtable">
<tr>
<td>Type  </td><td>Value(s)   </td></tr>
<tr>
<td>Aliased Set  </td><td>The symbol number of the aliased set, or zero for the universe   </td></tr>
<tr>
<td>Set  </td><td>Zero   </td></tr>
<tr>
<td>Parameter  </td><td>Zero   </td></tr>
<tr>
<td>Variable  </td><td>The variable type: binary=1, integer=2, positive=3, negative=4, free=5, sos1=6, sos2=7, semicontinous=8, semiinteger=9   </td></tr>
<tr>
<td>Equation  </td><td>The equation type: eque=53, equg=54, equl=55, equn=56, equx=57, equc=58, equb=59   </td></tr>
</table>
</td></tr>
    <tr><td class="paramname">ExplTxt</td><td>Explanatory text for the symbol. Buffer for this output argument should be 256 bytes long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Make sure the output argument string buffer for ExplTxt has size of 256 bytes. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the symbol number is not in the correct range, non-zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a96fccb045a2f3eab80d4b091c8224376" title="Returns the number of symbols and unique elements. Always non-zero.">gdxSystemInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a8f6f6ffff7ed12a048c8d4afcbe106fd" title="Returns information (name, dimension count, type) about a symbol from the symbol table....">gdxSymbolInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#abf4156f064b906dbf1052d39ceb2f6b9" title="Search for a symbol by name in the symbol table; the search is not case-sensitive.">gdxFindSymbol</a> </dd></dl>

</div>
</div>
<a id="a3955eaf00687760c2b7cdce9c9eb9fd7" name="a3955eaf00687760c2b7cdce9c9eb9fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3955eaf00687760c2b7cdce9c9eb9fd7">&#9670;&#160;</a></span>gdxSymbolSetDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbolSetDomain </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>DomainIDs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the domain of a symbol for which a write data operation just started using DataWriteRawStart, DataWriteMapStart or DataWriteStrStart. Returns zero if the operation is not possible. </p>
<p >This function defines the domain for the symbol for which a write data operation just started using DataWriteRawStart, DataWriteMapStart or DataWriteStrStart. At this point the symbol and dimension is known, but no data has been written yet. Each identifier will be checked to be a one dimensional set or an alias. When a domain is specified, write operations will be domain checked; records violating the domain will be added the the internal error list (see DataErrorCount and DataErrorRecord). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DomainIDs</td><td>Array of identifiers (domain names) or "*" (universe). One domain name for each symbol dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Make sure there is one buffer with size 64 bytes for each symbol dimension. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#acf107aae2a6daf07c721f1a2ce8e70a5" title="Retrieve the domain of a symbol. Returns zero if the operation is not possible.">gdxSymbolGetDomain</a> </dd></dl>

</div>
</div>
<a id="a39687019d377ad28428f052d49672ac1" name="a39687019d377ad28428f052d49672ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39687019d377ad28428f052d49672ac1">&#9670;&#160;</a></span>gdxSymbolSetDomainX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSymbolSetDomainX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>DomainIDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the domain of a symbol (relaxed version). Returns zero if the operation is not possible. </p>
<p >This function defines the relaxed domain information for the symbol SyNr. The identifiers will NOT be checked to be known one-dimensional sets, and no domain checking will be performed. This function can be called during or after the write operation. If domain checking is needed, use gdxSymbolSetDomain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyNr</td><td>The index number of the symbol, range from 0 to NrSymbols; SyNr = 0 reads universe. </td></tr>
    <tr><td class="paramname">DomainIDs</td><td>Array of identifiers (domain names) or "*" (universe). One domain name per symbol dimension with not more than 63 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a3955eaf00687760c2b7cdce9c9eb9fd7" title="Define the domain of a symbol for which a write data operation just started using DataWriteRawStart,...">gdxSymbolSetDomain</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a2b75bb5610c7bb4c710b0c312074edeb" title="Retrieve the domain of a symbol (using relaxed or domain information). Returns zero if the operation ...">gdxSymbolGetDomainX</a> </dd></dl>

</div>
</div>
<a id="a96fccb045a2f3eab80d4b091c8224376" name="a96fccb045a2f3eab80d4b091c8224376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fccb045a2f3eab80d4b091c8224376">&#9670;&#160;</a></span>gdxSystemInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxSystemInfo </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>SyCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UelCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of symbols and unique elements. Always non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyCnt</td><td>Number of symbols (sets, parameters, ...) available in the GDX file. </td></tr>
    <tr><td class="paramname">UelCnt</td><td>Number of unique elements (UELs) stored in the GDX file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a non-zero value. </dd></dl>

</div>
</div>
<a id="a63d3826003c3392656f5fff96140a6db" name="a63d3826003c3392656f5fff96140a6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d3826003c3392656f5fff96140a6db">&#9670;&#160;</a></span>gdxUELMaxLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUELMaxLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the longest unique element (UEL) name. </p>
<dl class="section return"><dt>Returns</dt><dd>The length of the longest UEL name in the UEL table. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#af7de4b7f90ec26e71c54b6e1df1e8595" title="Returns the length of the longest UEL used for every index position for a given symbol.">gdxSymbIndxMaxLength</a> </dd></dl>

</div>
</div>
<a id="aec362a592dc0213a5b21094a549053a5" name="aec362a592dc0213a5b21094a549053a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec362a592dc0213a5b21094a549053a5">&#9670;&#160;</a></span>gdxUELRegisterDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUELRegisterDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish registration of unique elements. Returns zero if the operation is not possible. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#af39b863999089bcb61b5d58014603fb3" title="Start registering unique elements in raw mode. Returns zero if the operation is not possible.">gdxUELRegisterRawStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a2752ae59f395cc46e7333cca006439dc" title="Start registering unique elements in mapped mode. Returns zero if the operation is not possible.">gdxUELRegisterMapStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#a1c27a9ff79464cc7d4f2be29e96cb22d" title="Start registering unique elements in string mode. Returns zero if the operation is not possible.">gdxUELRegisterStrStart</a> </dd></dl>

</div>
</div>
<a id="a9113a622565539f5ae9babd4633a9ccc" name="a9113a622565539f5ae9babd4633a9ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9113a622565539f5ae9babd4633a9ccc">&#9670;&#160;</a></span>gdxUELRegisterMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUELRegisterMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Uel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register unique element in mapped mode. A unique element must follow the GAMS rules when it contains quote characters. Returns zero if the operation is not possible. </p>
<p >UMap is the user assigned index for the element. Registering an element a second time is not considered an error as long as the same UMap is used. Assigning different elements with the same UMap value is an error. A unique element must follow the GAMS rules when it contains quote characters and not exceed 63 characters length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UMap</td><td>User index number to be assigned to the unique element, -1 if not found or the element was never mapped. </td></tr>
    <tr><td class="paramname">Uel</td><td>String for unique element (max. 63 chars and no single-/double-quote mixing). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a2752ae59f395cc46e7333cca006439dc" title="Start registering unique elements in mapped mode. Returns zero if the operation is not possible.">gdxUELRegisterMapStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aec362a592dc0213a5b21094a549053a5" title="Finish registration of unique elements. Returns zero if the operation is not possible.">gdxUELRegisterDone</a> </dd></dl>

</div>
</div>
<a id="a2752ae59f395cc46e7333cca006439dc" name="a2752ae59f395cc46e7333cca006439dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2752ae59f395cc46e7333cca006439dc">&#9670;&#160;</a></span>gdxUELRegisterMapStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUELRegisterMapStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start registering unique elements in mapped mode. Returns zero if the operation is not possible. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a9113a622565539f5ae9babd4633a9ccc" title="Register unique element in mapped mode. A unique element must follow the GAMS rules when it contains ...">gdxUELRegisterMap</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aec362a592dc0213a5b21094a549053a5" title="Finish registration of unique elements. Returns zero if the operation is not possible.">gdxUELRegisterDone</a> </dd></dl>

</div>
</div>
<a id="a3ab4081a598f1a88e34c19a3a841dfa2" name="a3ab4081a598f1a88e34c19a3a841dfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab4081a598f1a88e34c19a3a841dfa2">&#9670;&#160;</a></span>gdxUELRegisterRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUELRegisterRaw </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Uel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register unique element in raw mode. This can only be used while writing to a GDX file. Returns zero if the operation is not possible. </p>
<p >The unique element (UEL) is registered in raw mode, i.e. the internally assigned integer index is determined by the system. Can only be used while writing to a GDX file and gdxUELRegisterRawStart was called beforehand. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Uel</td><td>String for unique element (UEL) which may not exceed 63 characters in length. Furthermore a UEL string must not mix single- and double-quotes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a9113a622565539f5ae9babd4633a9ccc" title="Register unique element in mapped mode. A unique element must follow the GAMS rules when it contains ...">gdxUELRegisterMap</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aec362a592dc0213a5b21094a549053a5" title="Finish registration of unique elements. Returns zero if the operation is not possible.">gdxUELRegisterDone</a> </dd></dl>

</div>
</div>
<a id="af39b863999089bcb61b5d58014603fb3" name="af39b863999089bcb61b5d58014603fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39b863999089bcb61b5d58014603fb3">&#9670;&#160;</a></span>gdxUELRegisterRawStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUELRegisterRawStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start registering unique elements in raw mode. Returns zero if the operation is not possible. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a3ab4081a598f1a88e34c19a3a841dfa2" title="Register unique element in raw mode. This can only be used while writing to a GDX file....">gdxUELRegisterRaw</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aec362a592dc0213a5b21094a549053a5" title="Finish registration of unique elements. Returns zero if the operation is not possible.">gdxUELRegisterDone</a> </dd></dl>

</div>
</div>
<a id="a626c87515b7f8bb1527020845907a938" name="a626c87515b7f8bb1527020845907a938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626c87515b7f8bb1527020845907a938">&#9670;&#160;</a></span>gdxUELRegisterStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUELRegisterStr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Uel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UelNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a unique element in string mode. A unique element must follow the GAMS rules when it contains quote characters. Non-zero if the element was registered, zero otherwise. </p>
<p >The unique element is registered in user mapped space. The returned index is the next higher value. Registering an element a second time is not considered an error and the same index position will be returned. A unique element must follow the GAMS rules when it contains quote characters. Can only be used while writing to a GDX file and gdxUELRegisterStrStart was called beforehand. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Uel</td><td>String for unique element (UEL) which may not exceed a length of 63 characters. Furthermore a UEL string must not mix single- and double-quotes. </td></tr>
    <tr><td class="paramname">UelNr</td><td>Internal index number assigned to this unique element in user space (or -1 if not found). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the element was registered, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a1c27a9ff79464cc7d4f2be29e96cb22d" title="Start registering unique elements in string mode. Returns zero if the operation is not possible.">gdxUELRegisterStrStart</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aec362a592dc0213a5b21094a549053a5" title="Finish registration of unique elements. Returns zero if the operation is not possible.">gdxUELRegisterDone</a> </dd></dl>

</div>
</div>
<a id="a1c27a9ff79464cc7d4f2be29e96cb22d" name="a1c27a9ff79464cc7d4f2be29e96cb22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c27a9ff79464cc7d4f2be29e96cb22d">&#9670;&#160;</a></span>gdxUELRegisterStrStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUELRegisterStrStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start registering unique elements in string mode. Returns zero if the operation is not possible. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a626c87515b7f8bb1527020845907a938" title="Register a unique element in string mode. A unique element must follow the GAMS rules when it contain...">gdxUELRegisterStr</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#aec362a592dc0213a5b21094a549053a5" title="Finish registration of unique elements. Returns zero if the operation is not possible.">gdxUELRegisterDone</a> </dd></dl>

</div>
</div>
<a id="ab56b11d2fed8aeb94082880ab65b5d72" name="ab56b11d2fed8aeb94082880ab65b5d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56b11d2fed8aeb94082880ab65b5d72">&#9670;&#160;</a></span>gdxUMFindUEL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUMFindUEL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Uel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UelNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UelMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for unique element by its string. Non-zero if the element was found, zero otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Uel</td><td>String to be searched (not longer than 63 characters, don't mix single- and double-quotes). </td></tr>
    <tr><td class="paramname">UelNr</td><td>Internal unique element number or -1 if not found. </td></tr>
    <tr><td class="paramname">UelMap</td><td>User mapping for the element or -1 if not found or the element was never mapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the element was found, zero otherwise. </dd></dl>

</div>
</div>
<a id="a8aa4bee81394262223a74e7283daa0f0" name="a8aa4bee81394262223a74e7283daa0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa4bee81394262223a74e7283daa0f0">&#9670;&#160;</a></span>gdxUMUelGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUMUelGet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UelNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Uel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UelMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a unique element using an unmapped index. Returns zero if the operation is not possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UelNr</td><td>Element number (unmapped) (range 1..NrElem) or -1 if not found. </td></tr>
    <tr><td class="paramname">Uel</td><td>String for unique element. Buffer should be 64 bytes long (to store maximum of 63 characters). </td></tr>
    <tr><td class="paramname">UelMap</td><td>User mapping for this element or -1 if element was never mapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Make sure buffer for Uel is at least 64 bytes long to prevent potential overflow. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the operation is possible, zero otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a220668a85337531cec7984c9d757f5e3" title="Return information about the unique elements (UELs). Always non-zero.">gdxUMUelInfo</a>, <a class="el" href="classgdx_1_1TGXFileObj.html#ace4928e7d18a0365c3c0af5aa7f0c65a" title="Get the string for a unique element using a mapped index. Returns zero if the operation is not possib...">gdxGetUEL</a> </dd></dl>

</div>
</div>
<a id="a220668a85337531cec7984c9d757f5e3" name="a220668a85337531cec7984c9d757f5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220668a85337531cec7984c9d757f5e3">&#9670;&#160;</a></span>gdxUMUelInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdx::TGXFileObj::gdxUMUelInfo </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UelCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>HighMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return information about the unique elements (UELs). Always non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UelCnt</td><td>Total number of unique elements (UELs in GDX file plus new registered UELs). </td></tr>
    <tr><td class="paramname">HighMap</td><td>Highest user mapping index used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns non-zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgdx_1_1TGXFileObj.html#a8aa4bee81394262223a74e7283daa0f0" title="Get a unique element using an unmapped index. Returns zero if the operation is not possible.">gdxUMUelGet</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="gdx_8h_source.html">gdx.h</a></li>
<li>src/gxfile.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>gdx</b></li><li class="navelem"><a class="el" href="classgdx_1_1TGXFileObj.html">TGXFileObj</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
