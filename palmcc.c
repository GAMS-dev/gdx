/* C code generated by apiwrapper for GAMS Version 43.0.0
 *
 * GAMS - Loading mechanism for GAMS Expert-Level APIs
 *
 * Copyright (c) 2016-2023 GAMS Software GmbH <support@gams.com>
 * Copyright (c) 2016-2023 GAMS Development Corp. <support@gams.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>

#define PAL_MAIN
#include "palmcc.h"

#if defined(_WIN32)
# include <Windows.h>
  static char winErr[] = "Windows error";
  typedef HINSTANCE soHandle_t;
#else
# include <unistd.h>
# include <dlfcn.h>
# include <sys/utsname.h>
  typedef void *soHandle_t;
#endif

static soHandle_t h;
static int isLoaded = 0;
static int objectCount = 0;
static int ScreenIndicator = 1;
static int ExceptionIndicator = 0;
static int ExitIndicator = 1;
static palErrorCallback_t ErrorCallBack = NULL;
static int APIErrorCount = 0;

#if !defined(GC_NO_MUTEX)
#include "gcmt.h"
static GC_mutex_t libMutex;
static GC_mutex_t objMutex;
static GC_mutex_t exceptMutex;

static int MutexIsInitialized = 0;

void palInitMutexes(void)
{
  int rc;
  if (0==MutexIsInitialized) {
    rc = GC_mutex_init (&libMutex);     if(0!=rc) palErrorHandling("Problem initializing libMutex");
    rc = GC_mutex_init (&objMutex);     if(0!=rc) palErrorHandling("Problem initializing objMutex");
    rc = GC_mutex_init (&exceptMutex);  if(0!=rc) palErrorHandling("Problem initializing exceptMutex");
    MutexIsInitialized = 1;
  }
}

void palFiniMutexes(void)
{
  if (1==MutexIsInitialized) {
    GC_mutex_delete (&libMutex);
    GC_mutex_delete (&objMutex);
    GC_mutex_delete (&exceptMutex);
    MutexIsInitialized = 0;
  }
}
#  define lock(MUTEX)   if(MutexIsInitialized) GC_mutex_lock (&MUTEX);
#  define unlock(MUTEX) if(MutexIsInitialized) GC_mutex_unlock (&MUTEX);
#else
#  define lock(MUTEX)   ;
#  define unlock(MUTEX) ;
void palInitMutexes(void) {}
void palFiniMutexes(void) {}
#endif

#if !defined(GAMS_UNUSED)
#define GAMS_UNUSED(x) (void)x;
#endif

typedef void (PAL_CALLCONV *palXCreate_t) (palHandle_t *ppal);
static PAL_FUNCPTR(palXCreate);
typedef void (PAL_CALLCONV *palXFree_t)   (palHandle_t *ppal);
static PAL_FUNCPTR(palXFree);
typedef int (PAL_CALLCONV *palXAPIVersion_t) (int api, char *msg, int *cl);
static PAL_FUNCPTR(palXAPIVersion);
typedef int (PAL_CALLCONV *palXCheck_t) (const char *ep, int nargs, int s[], char *msg);
static PAL_FUNCPTR(palXCheck);
#define printNoReturn(f,nargs) { \
  char d_msgBuf[256]; \
  strcpy(d_msgBuf,#f " could not be loaded: "); \
  palXCheck(#f,nargs,d_s,d_msgBuf+strlen(d_msgBuf)); \
  palErrorHandling(d_msgBuf); \
}
#define printAndReturn(f,nargs,rtype) { \
  char d_msgBuf[256]; \
  strcpy(d_msgBuf,#f " could not be loaded: "); \
  palXCheck(#f,nargs,d_s,d_msgBuf+strlen(d_msgBuf)); \
  palErrorHandling(d_msgBuf); \
  return (rtype) 0; \
}


/** Sets audit string
 * @param ppal pal object handle
 * @param auditline audit line
 */
void  PAL_CALLCONV d_palSetAuditLine (palHandle_t ppal, const char *auditline)
{
  int d_s[]={0,11};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(auditline)
  printNoReturn(palSetAuditLine,1)
}

/** Sets system name and sets up a generic audit string
 * @param ppal pal object handle
 * @param sname name of solver/subsystem
 */
void  PAL_CALLCONV d_palSetSystemName (palHandle_t ppal, const char *sname)
{
  int d_s[]={0,11};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(sname)
  printNoReturn(palSetSystemName,1)
}

/** Indicator for an audit run
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palAuditRun (palHandle_t ppal)
{
  int d_s[]={15};
  GAMS_UNUSED(ppal)
  printAndReturn(palAuditRun,0,int )
}

/** Gets audit string
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetAuditLine (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetAuditLine,0,char *)
}

/** Gets copyright string
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetCpr (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetCpr,0,char *)
}

/** Major and Minor number combined as an int like 239
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palGetVer (palHandle_t ppal)
{
  int d_s[]={3};
  GAMS_UNUSED(ppal)
  printAndReturn(palGetVer,0,int )
}

/** Gets Major.Minor like 23.9
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetRel (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetRel,0,char *)
}

/** Gets Maintenance number like 2 for 23.9.2
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetGold (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetGold,0,char *)
}

/** Gets Platform code like WIN
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetCod (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetCod,0,char *)
}

/** Gets Platform text like x86/MS Windows
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetHdr (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetHdr,0,char *)
}

/** Get license check date as Julian number
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palGetJul (palHandle_t ppal)
{
  int d_s[]={3};
  GAMS_UNUSED(ppal)
  printAndReturn(palGetJul,0,int )
}

/** Gets build date like "Sep 19, 2012"
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetLicDat (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetLicDat,0,char *)
}

/** Gets build code like LEG
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetBldCod (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetBldCod,0,char *)
}

/** Gets license check date like "Dec  3, 2021  (ALPHA)" or "Dec  3, 2021        "
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetRelDat (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetRelDat,0,char *)
}

/** Gets global SVN revision number like r123456
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetRevision (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetRevision,0,char *)
}

/** Indicator for an beta system
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palIsBeta (palHandle_t ppal)
{
  int d_s[]={15};
  GAMS_UNUSED(ppal)
  printAndReturn(palIsBeta,0,int )
}

/** Indicator for an alpha system (deprecated)
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palIsAlfa (palHandle_t ppal)
{
  int d_s[]={15};
  GAMS_UNUSED(ppal)
  printAndReturn(palIsAlfa,0,int )
}

/** Indicator for an alpha system
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palIsAlpha (palHandle_t ppal)
{
  int d_s[]={15};
  GAMS_UNUSED(ppal)
  printAndReturn(palIsAlpha,0,int )
}

/** Get todays date as Julian number
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palGetToday (palHandle_t ppal)
{
  int d_s[]={3};
  GAMS_UNUSED(ppal)
  printAndReturn(palGetToday,0,int )
}

/** Get julian date from the string yymmdd
 * @param ppal pal object handle
 * @param s 
 */
int  PAL_CALLCONV d_palGetJulianDays (palHandle_t ppal, const char *s)
{
  int d_s[]={3,11};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(s)
  printAndReturn(palGetJulianDays,1,int )
}

/** Chops audit line apart
 * @param ppal pal object handle
 * @param auditline audit line
 * @param v1 product part of audit line
 * @param v2 distribution info of audit line
 * @param v3 rest of audit line
 */
void  PAL_CALLCONV d_palAuditFields (palHandle_t ppal, const char *auditline, char *v1, char *v2, char *v3)
{
  int d_s[]={0,11,12,12,12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(auditline)
  GAMS_UNUSED(v1)
  GAMS_UNUSED(v2)
  GAMS_UNUSED(v3)
  printNoReturn(palAuditFields,4)
}

/** Gets a short audit line
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palGetShortAuditLine (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palGetShortAuditLine,0,char *)
}

/** Reads license file in various line formats
 * @param ppal pal object handle
 * @param filename name of the license file to read
 * @param msg message
 * @param rc return code
 */
int  PAL_CALLCONV d_palLicenseReadU (palHandle_t ppal, const char *filename, char *msg, int *rc)
{
  int d_s[]={15,11,12,21};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(filename)
  GAMS_UNUSED(msg)
  GAMS_UNUSED(rc)
  printAndReturn(palLicenseReadU,3,int )
}

/** Registers a line of the license file
 * @param ppal pal object handle
 * @param linenr license file line number
 * @param liceline license file line
 */
void  PAL_CALLCONV d_palLicenseRegisterGAMS (palHandle_t ppal, int linenr, const char *liceline)
{
  int d_s[]={0,3,11};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(linenr)
  GAMS_UNUSED(liceline)
  printNoReturn(palLicenseRegisterGAMS,2)
}

/** Retrieve a line of the license file
 * @param ppal pal object handle
 * @param linenr license file line number
 */
char * PAL_CALLCONV d_palLicenseGetLLine (palHandle_t ppal, int linenr, char *buf)
{
  int d_s[]={12,3};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(linenr)
  GAMS_UNUSED(buf)
  printAndReturn(palLicenseGetLLine,1,char *)
}

/** Completion of license registration
 * @param ppal pal object handle
 */
void  PAL_CALLCONV d_palLicenseRegisterGAMSDone (palHandle_t ppal)
{
  int d_s[]={0};
  GAMS_UNUSED(ppal)
  printNoReturn(palLicenseRegisterGAMSDone,0)
}

/** Registers the system to be licensed
 * @param ppal pal object handle
 * @param numcodes number of license codes for system
 * @param codes license codes for system
 * @param magicnum magic number
 */
void  PAL_CALLCONV d_palLicenseRegisterSystem (palHandle_t ppal, int numcodes, const char *codes, int magicnum)
{
  int d_s[]={0,3,11,3};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(numcodes)
  GAMS_UNUSED(codes)
  GAMS_UNUSED(magicnum)
  printNoReturn(palLicenseRegisterSystem,3)
}

/** Validates license and returns true on failure
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palLicenseValidation (palHandle_t ppal)
{
  int d_s[]={15};
  GAMS_UNUSED(ppal)
  printAndReturn(palLicenseValidation,0,int )
}

/** Checks if system with codes is licensed and returns true on failure uses registered size
 * @param ppal pal object handle
 * @param codes license codes for system
 */
int  PAL_CALLCONV d_palLicenseSolverCheck (palHandle_t ppal, const char *codes)
{
  int d_s[]={15,11};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(codes)
  printAndReturn(palLicenseSolverCheck,1,int )
}

/** Checks if system with codes is licensed and returns true on failure uses sizes from arguments
 * @param ppal pal object handle
 * @param codes license codes for system
 * @param M number of equations
 * @param N number of variables
 * @param NZ number of non-zeros
 * @param NLNZ number of non-linear non-zeros
 * @param NDisc number of discrete variables
 */
int  PAL_CALLCONV d_palLicenseSolverCheckSizes (palHandle_t ppal, const char *codes, int M, int N, int NZ, int NLNZ, int NDisc)
{
  int d_s[]={15,11,3,3,3,3,3};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(codes)
  GAMS_UNUSED(M)
  GAMS_UNUSED(N)
  GAMS_UNUSED(NZ)
  GAMS_UNUSED(NLNZ)
  GAMS_UNUSED(NDisc)
  printAndReturn(palLicenseSolverCheckSizes,6,int )
}

/** Checks if system with codes is licensed and returns true on failure uses sizes from arguments
 * @param ppal pal object handle
 * @param codes license codes for system
 * @param M number of equations
 * @param N number of variables
 * @param NZ number of non-zeros
 * @param NLNZ number of non-linear non-zeros
 * @param NDisc number of discrete variables
 */
int  PAL_CALLCONV d_palLicenseSolverCheckSizes64 (palHandle_t ppal, const char *codes, int M, int N, INT64 NZ, INT64 NLNZ, int NDisc)
{
  int d_s[]={15,11,3,3,23,23,3};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(codes)
  GAMS_UNUSED(M)
  GAMS_UNUSED(N)
  GAMS_UNUSED(NZ)
  GAMS_UNUSED(NLNZ)
  GAMS_UNUSED(NDisc)
  printAndReturn(palLicenseSolverCheckSizes64,6,int )
}

/** Checks if system is licensed and returns true on failure
 * @param ppal pal object handle
 * @param M number of equations
 * @param N number of variables
 * @param NZ number of non-zeros
 * @param NLNZ number of non-linear non-zeros
 * @param NDisc number of discrete variables
 */
int  PAL_CALLCONV d_palLicenseCheck (palHandle_t ppal, int M, int N, int NZ, int NLNZ, int NDisc)
{
  int d_s[]={15,3,3,3,3,3};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(M)
  GAMS_UNUSED(N)
  GAMS_UNUSED(NZ)
  GAMS_UNUSED(NLNZ)
  GAMS_UNUSED(NDisc)
  printAndReturn(palLicenseCheck,5,int )
}

/** Checks if system is licensed and returns true on failure
 * @param ppal pal object handle
 * @param M number of equations
 * @param N number of variables
 * @param NZ number of non-zeros
 * @param NLNZ number of non-linear non-zeros
 * @param NDisc number of discrete variables
 */
int  PAL_CALLCONV d_palLicenseCheck64 (palHandle_t ppal, int M, int N, INT64 NZ, INT64 NLNZ, int NDisc)
{
  int d_s[]={15,3,3,23,23,3};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(M)
  GAMS_UNUSED(N)
  GAMS_UNUSED(NZ)
  GAMS_UNUSED(NLNZ)
  GAMS_UNUSED(NDisc)
  printAndReturn(palLicenseCheck64,5,int )
}

/** Retrieves message from license check
 * @param ppal pal object handle
 * @param msg message
 */
int  PAL_CALLCONV d_palLicenseGetMessage (palHandle_t ppal, char *msg, int msg_i)
{
  int d_s[]={15,17};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(msg)
  GAMS_UNUSED(msg_i)
  printAndReturn(palLicenseGetMessage,1,int )
}

/** Retrieves message about demo usage. Return indicates if message should be printed (true means print)
 * @param ppal pal object handle
 * @param msg message
 */
int  PAL_CALLCONV d_palPrintDemoMessage (palHandle_t ppal, char *msg, int msg_i)
{
  int d_s[]={15,17};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(msg)
  GAMS_UNUSED(msg_i)
  printAndReturn(palPrintDemoMessage,1,int )
}

/** Indicator if model fits in free GAMS limits (demo or community based on the actual license), returns true if that is the case, and false if the model is too big and a check for a license code is in order
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palLicenseIsGAMSCheckout (palHandle_t ppal)
{
  int d_s[]={15};
  GAMS_UNUSED(ppal)
  printAndReturn(palLicenseIsGAMSCheckout,0,int )
}

/** Indicator if license is academic
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palLicenseIsAcademic (palHandle_t ppal)
{
  int d_s[]={15};
  GAMS_UNUSED(ppal)
  printAndReturn(palLicenseIsAcademic,0,int )
}

/** Indicator if subsystem is licensed (true if not licenses)
 * @param ppal pal object handle
 * @param codes license codes for system
 */
int  PAL_CALLCONV d_palLicenseCheckSubSys (palHandle_t ppal, const char *codes)
{
  int d_s[]={15,11};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(codes)
  printAndReturn(palLicenseCheckSubSys,1,int )
}

/** Indicator if subsystem is licensed (true if not licenses, daysLeft will be >/< 0 for eval license)
 * @param ppal pal object handle
 * @param sname name of solver/subsystem
 * @param codes license codes for system
 * @param daysLeft remaining days of eval license (negative if expired)
 */
int  PAL_CALLCONV d_palLicenseCheckSubX (palHandle_t ppal, const char *sname, const char *codes, int *daysLeft)
{
  int d_s[]={15,11,11,21};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(sname)
  GAMS_UNUSED(codes)
  GAMS_UNUSED(daysLeft)
  printAndReturn(palLicenseCheckSubX,3,int )
}

/** Get platform code of license
 * @param ppal pal object handle
 */
char * PAL_CALLCONV d_palLicenseGetPlatform (palHandle_t ppal, char *buf)
{
  int d_s[]={12};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  printAndReturn(palLicenseGetPlatform,0,char *)
}

/** Returns data dirs in buf
 * @param ppal pal object handle
 * @param buf buffer to return a number of directories
 * @param bufsize size of buf
 * @param numdirs number of directories returned
 * @param offset vector of offsets into buf to access the individual directories
 * @param offsetsize size of offset vector
 * @param sysdir GAMS system directory
 */
int  PAL_CALLCONV d_palDataDirs (palHandle_t ppal, char *buf, int bufsize, int *numdirs, int offset[], int offsetsize, const char *sysdir)
{
  int d_s[]={15,10,3,4,8,3,11};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  GAMS_UNUSED(bufsize)
  GAMS_UNUSED(numdirs)
  GAMS_UNUSED(offset)
  GAMS_UNUSED(offsetsize)
  GAMS_UNUSED(sysdir)
  printAndReturn(palDataDirs,6,int )
}

/** Returns config dirs in buf
 * @param ppal pal object handle
 * @param buf buffer to return a number of directories
 * @param bufsize size of buf
 * @param numdirs number of directories returned
 * @param offset vector of offsets into buf to access the individual directories
 * @param offsetsize size of offset vector
 * @param sysdir GAMS system directory
 */
int  PAL_CALLCONV d_palConfigDirs (palHandle_t ppal, char *buf, int bufsize, int *numdirs, int offset[], int offsetsize, const char *sysdir)
{
  int d_s[]={15,10,3,4,8,3,11};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(buf)
  GAMS_UNUSED(bufsize)
  GAMS_UNUSED(numdirs)
  GAMS_UNUSED(offset)
  GAMS_UNUSED(offsetsize)
  GAMS_UNUSED(sysdir)
  printAndReturn(palConfigDirs,6,int )
}

/** Access the license level
 * @param ppal pal object handle
 */
int  PAL_CALLCONV d_palLicenseLevel (palHandle_t ppal)
{
  int d_s[]={3};
  GAMS_UNUSED(ppal)
  printAndReturn(palLicenseLevel,0,int )
}

/** Access the license level
 * @param ppal pal object handle
 */
void PAL_CALLCONV d_palLicenseLevelSet (palHandle_t ppal,const int x)
{
  int d_s[]={0,3};
  GAMS_UNUSED(ppal)
  GAMS_UNUSED(x)
  printNoReturn(palLicenseLevelSet,1)
}


/** return dirName on success, NULL on failure */
static char *
extractFileDirFileName (const char *fileName, char *dirName, char *fName)
{
  int fileNameLen, shave=0;
  const char *end, *s;
  char *t;

  if (NULL == fileName || NULL == dirName || fName == NULL) {
    return NULL;
  }
  fileNameLen = (int) strlen(fileName);

#if defined(_WIN32)
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '\\' != *end && ':' != *end;  end--);
  /* shave off the trailing delimiter if:
   *  it isn't the first char,
   *  it is a backslash, and
   *  it is not preceded by a delimiter
   */
  if (end > fileName && '\\' == *end
   && (! ('\\' == *(end-1) || ':' == *(end-1)))
     ) {
    end--; shave=1;
  }
#else
  /* non-Windows: implicitly, this is the Unix version */
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '/' != *end;  end--);

  if (end > fileName && '/' == *end) {
    end--; shave=1;
  }
#endif  /* if defined(_WIN32) */

  for (s = fileName, t = dirName;  s <= end;  s++, t++)
    *t = *s;
  *t = '\0';

  if (shave) s++;
  for (t = fName;  s <= fileName + fileNameLen - 1;  s++, t++)
    *t = *s;
  *t = '\0';

  return dirName;
} /* extractFileDirFileName */

static soHandle_t
loadLib (const char *libName, char **errMsg)
{
  soHandle_t h;

#if defined(_WIN32)
#if defined(UNICODE) || defined (_UNICODE)
  h = LoadLibraryA(libName);
#else
  h = LoadLibrary(libName);
#endif
  if (NULL == h) {
    *errMsg = winErr;
  }
  else {
    *errMsg = NULL;
  }
#else
  (void) dlerror();
  h = dlopen (libName, RTLD_NOW);
  if (NULL == h) {
    *errMsg = dlerror();
  }
  else {
    *errMsg = NULL;
  }
#endif

  return h;
} /* loadLib */

static int
unLoadLib (soHandle_t hh)
{
  int rc;

#if defined(_WIN32)
  rc = FreeLibrary (hh);
  return ! rc;
#else
  rc = dlclose (hh);
#endif
  return rc;
} /* unLoadLib */

static void *
loadSym (soHandle_t h, const char *sym, char **errMsg)
{
  void *s;
  const char *from;
  char *to;
  const char *tripSym;
  char lcbuf[257];
  char ucbuf[257];
  size_t symLen;
  int trip;

  /* search in this order:
   *  1. lower
   *  2. original
   *  3. upper
   */

  symLen = 0;
  for (trip = 1;  trip <= 3;  trip++) {
    switch (trip) {
    case 1:                             /* lower */
      for (from = sym, to = lcbuf;  *from;  from++, to++) {
        *to = tolower(*from);
      }
      symLen = from - sym;
      lcbuf[symLen] = '\0';
      tripSym = lcbuf;
      break;
    case 2:                             /* original */
      tripSym = sym;
      break;
    case 3:                             /* upper */
      for (from = sym, to = ucbuf;  *from;  from++, to++) {
        *to = toupper(*from);
      }
      ucbuf[symLen] = '\0';
      tripSym = ucbuf;
      break;
    default:
      tripSym = sym;
    } /* end switch */
#if defined(_WIN32)
#  if defined(HAVE_INTPTR_T)
    s = (void *)(intptr_t)GetProcAddress (h, tripSym);
#  else
    s = (void *)GetProcAddress (h, tripSym);
#  endif
    *errMsg = NULL;
    if (NULL != s) {
      return s;
    }
#else
    (void) dlerror();
    s = dlsym (h, tripSym);
    *errMsg = dlerror();
    if (NULL == *errMsg) {
      return s;
    }
#endif
  } /* end loop over symbol name variations */

  return NULL;
} /* loadSym */

/* TNAME = type name, ENAME = exported name */
#if defined(HAVE_INTPTR_T)
#  define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) (intptr_t) loadSym (h, symName, &errMsg); if (NULL == TNAME) goto symMissing
#  define LOADIT_ERR_OK(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) (intptr_t) loadSym (h, symName, &errMsg)
#else
#  define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (h, symName, &errMsg); if (NULL == TNAME) goto symMissing
#  define LOADIT_ERR_OK(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (h, symName, &errMsg)
#endif

#if ! defined(GMS_DLL_BASENAME)
# define GMS_DLL_BASENAME "joatdclib"
#endif
#if defined(_WIN32)
# if ! defined(GMS_DLL_PREFIX)
#  define GMS_DLL_PREFIX ""
# endif
# if ! defined(GMS_DLL_EXTENSION)
#  define GMS_DLL_EXTENSION ".dll"
# endif
# if ! defined(GMS_DLL_SUFFIX)
#  if defined(_WIN64)
#   define GMS_DLL_SUFFIX "64"
#  else
#   define GMS_DLL_SUFFIX ""
#  endif
# endif

#else  /* start non-Windows */

# if ! defined(GMS_DLL_PREFIX)
#  define GMS_DLL_PREFIX "lib"
# endif
# if ! defined(GMS_DLL_EXTENSION)
#  if defined(__APPLE__)
#   define GMS_DLL_EXTENSION ".dylib"
#  else
#   define GMS_DLL_EXTENSION ".so"
#  endif
# endif
# if ! defined(GMS_DLL_SUFFIX)
#  if defined(__WORDSIZE)
#   if 64 == __WORDSIZE
#    define GMS_DLL_SUFFIX "64"
#   else
#    define GMS_DLL_SUFFIX ""
#   endif
#  elif defined(__SIZEOF_POINTER__)
#   if 4 == __SIZEOF_POINTER__
#    define GMS_DLL_SUFFIX ""
#   elif 8 == __SIZEOF_POINTER__
#    define GMS_DLL_SUFFIX "64"
#   endif
#  endif
# endif /* ! defined(GMS_DLL_SUFFIX) */
#endif

/** XLibraryLoad: return 0 on success, ~0 on failure */
static int
XLibraryLoad (const char *dllName, char *errBuf, int errBufSize)
{
  char *errMsg;
  const char *symName;
  int rc, cl;

  if (isLoaded)
    return 0;
  h = loadLib (dllName, &errMsg);
  if (NULL == h) {
    if (NULL != errBuf) {
      int elen;
      char* ebuf;
      elen = errBufSize;  ebuf = errBuf;
      rc = sprintf (ebuf, "%.*s", elen, "Could not load shared library ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, dllName);
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, ": ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, errMsg);
      /* elen -= rc;  ebuf+= rc; */
      errBuf[errBufSize-1] = '\0';
    }
    return 1;
  }
  else {
     /* printf ("Loaded shared library %s successfully\n", dllName); */
    if (errBuf && errBufSize)
      errBuf[0] = '\0';
  }

  LOADIT(palXCreate, "palXCreate");
  LOADIT(palXFree, "palXFree");
  LOADIT(palXCheck, "CpalXCheck");
  LOADIT(palXAPIVersion, "CpalXAPIVersion");

  if (!palXAPIVersion(5,errBuf,&cl))
    return 1;

#define CheckAndLoad(f,nargs,prefix) \
  if (!palXCheck(#f,nargs,s,errBuf)) \
    f = &d_##f; \
  else { \
    LOADIT(f,prefix #f); \
  }
  {int s[]={0,11}; CheckAndLoad(palSetAuditLine,1,"C"); }
  {int s[]={0,11}; CheckAndLoad(palSetSystemName,1,"C"); }
  {int s[]={15}; CheckAndLoad(palAuditRun,0,""); }
  {int s[]={12}; CheckAndLoad(palGetAuditLine,0,"C"); }
  {int s[]={12}; CheckAndLoad(palGetCpr,0,"C"); }
  {int s[]={3}; CheckAndLoad(palGetVer,0,""); }
  {int s[]={12}; CheckAndLoad(palGetRel,0,"C"); }
  {int s[]={12}; CheckAndLoad(palGetGold,0,"C"); }
  {int s[]={12}; CheckAndLoad(palGetCod,0,"C"); }
  {int s[]={12}; CheckAndLoad(palGetHdr,0,"C"); }
  {int s[]={3}; CheckAndLoad(palGetJul,0,""); }
  {int s[]={12}; CheckAndLoad(palGetLicDat,0,"C"); }
  {int s[]={12}; CheckAndLoad(palGetBldCod,0,"C"); }
  {int s[]={12}; CheckAndLoad(palGetRelDat,0,"C"); }
  {int s[]={12}; CheckAndLoad(palGetRevision,0,"C"); }
  {int s[]={15}; CheckAndLoad(palIsBeta,0,""); }
  {int s[]={15}; CheckAndLoad(palIsAlfa,0,""); }
  {int s[]={15}; CheckAndLoad(palIsAlpha,0,""); }
  {int s[]={3}; CheckAndLoad(palGetToday,0,""); }
  {int s[]={3,11}; CheckAndLoad(palGetJulianDays,1,"C"); }
  {int s[]={0,11,12,12,12}; CheckAndLoad(palAuditFields,4,"C"); }
  {int s[]={12}; CheckAndLoad(palGetShortAuditLine,0,"C"); }
  {int s[]={15,11,12,21}; CheckAndLoad(palLicenseReadU,3,"C"); }
  {int s[]={0,3,11}; CheckAndLoad(palLicenseRegisterGAMS,2,"C"); }
  {int s[]={12,3}; CheckAndLoad(palLicenseGetLLine,1,"C"); }
  {int s[]={0}; CheckAndLoad(palLicenseRegisterGAMSDone,0,""); }
  {int s[]={0,3,11,3}; CheckAndLoad(palLicenseRegisterSystem,3,"C"); }
  {int s[]={15}; CheckAndLoad(palLicenseValidation,0,""); }
  {int s[]={15,11}; CheckAndLoad(palLicenseSolverCheck,1,"C"); }
  {int s[]={15,11,3,3,3,3,3}; CheckAndLoad(palLicenseSolverCheckSizes,6,"C"); }
  {int s[]={15,11,3,3,23,23,3}; CheckAndLoad(palLicenseSolverCheckSizes64,6,"C"); }
  {int s[]={15,3,3,3,3,3}; CheckAndLoad(palLicenseCheck,5,""); }
  {int s[]={15,3,3,23,23,3}; CheckAndLoad(palLicenseCheck64,5,""); }
  {int s[]={15,17}; CheckAndLoad(palLicenseGetMessage,1,"C"); }
  {int s[]={15,17}; CheckAndLoad(palPrintDemoMessage,1,"C"); }
  {int s[]={15}; CheckAndLoad(palLicenseIsGAMSCheckout,0,""); }
  {int s[]={15}; CheckAndLoad(palLicenseIsAcademic,0,""); }
  {int s[]={15,11}; CheckAndLoad(palLicenseCheckSubSys,1,"C"); }
  {int s[]={15,11,11,21}; CheckAndLoad(palLicenseCheckSubX,3,"C"); }
  {int s[]={12}; CheckAndLoad(palLicenseGetPlatform,0,"C"); }
  {int s[]={15,10,3,4,8,3,11}; CheckAndLoad(palDataDirs,6,"C"); }
  {int s[]={15,10,3,4,8,3,11}; CheckAndLoad(palConfigDirs,6,"C"); }
  {int s[]={3}; CheckAndLoad(palLicenseLevel,0,""); }
  {int s[]={0,3}; CheckAndLoad(palLicenseLevelSet,1,""); }

 return 0;

 symMissing:
  if (errBuf && errBufSize>0) {
    int elen;
    char* ebuf;
    elen = errBufSize;  ebuf = errBuf;
    rc = sprintf (ebuf, "%.*s", elen, "Could not load symbol '");
    elen -= rc;  ebuf+= rc;
    rc = sprintf (ebuf, "%.*s", elen, symName);
    elen -= rc;  ebuf+= rc;
    rc = sprintf (ebuf, "%.*s", elen, "': ");
    elen -= rc;  ebuf+= rc;
    rc = sprintf (ebuf, "%.*s", elen, errMsg);
    /* elen -= rc;  ebuf+= rc; */
    errBuf[errBufSize-1] = '\0';
    /* printf ("%s\n", errBuf); */
    return 2;
  }

 return 0;

} /* XLibraryLoad */

static int
libloader(const char *dllPath, const char *dllName, char *msgBuf, int msgBufSize)
{

  char dllNameBuf[512];
  int myrc = 0;

#if ! defined(GMS_DLL_PREFIX)
# error "GMS_DLL_PREFIX expected but not defined"
#endif
#if ! defined(GMS_DLL_BASENAME)
# error "GMS_DLL_BASENAME expected but not defined"
#endif
#if ! defined(GMS_DLL_EXTENSION)
# error "GMS_DLL_EXTENSION expected but not defined"
#endif
#if ! defined(GMS_DLL_SUFFIX)
# error "GMS_DLL_SUFFIX expected but not defined"
#endif

  if (NULL != msgBuf) msgBuf[0] = '\0';

  if (! isLoaded) {
    if (NULL != dllPath && '\0' != *dllPath) {
      strncpy(dllNameBuf, dllPath, sizeof(dllNameBuf)-1);
      dllNameBuf[sizeof(dllNameBuf)-1] = '\0';
#if defined(_WIN32)
      if ('\\' != dllNameBuf[strlen(dllNameBuf)])
        strcat(dllNameBuf,"\\");
#else
      if ('/' != dllNameBuf[strlen(dllNameBuf)])
        strcat(dllNameBuf,"/");
#endif
    }
    else {
      dllNameBuf[0] = '\0';
    }
    if (NULL != dllName && '\0' != *dllName) {
      strncat(dllNameBuf, dllName, sizeof(dllNameBuf)-strlen(dllNameBuf)-1);
    }
    else {
      strncat(dllNameBuf, GMS_DLL_PREFIX GMS_DLL_BASENAME, sizeof(dllNameBuf)-strlen(dllNameBuf)-1);
      strncat(dllNameBuf, GMS_DLL_SUFFIX                 , sizeof(dllNameBuf)-strlen(dllNameBuf)-1);
      strncat(dllNameBuf, GMS_DLL_EXTENSION              , sizeof(dllNameBuf)-strlen(dllNameBuf)-1);
    }
    isLoaded = ! XLibraryLoad (dllNameBuf, msgBuf, msgBufSize);
    if (isLoaded) {
    }
    else {                              /* library load failed */
      myrc |= 1;
    }
  }
  return (myrc & 1) == 0;
}

int palGetReady (char *msgBuf, int msgBufSize)
{
  int rc;
  lock(libMutex);
  rc = libloader(NULL, NULL, msgBuf, msgBufSize);
  unlock(libMutex);
  return rc;
} /* palGetReady */

int palGetReadyD (const char *dirName, char *msgBuf, int msgBufSize)
{
  int rc;
  lock(libMutex);
  rc = libloader(dirName, NULL, msgBuf, msgBufSize);
  unlock(libMutex);
  return rc;
} /* palGetReadyD */

int palGetReadyL (const char *libName, char *msgBuf, int msgBufSize)
{
  char dirName[1024],fName[1024];
  int rc;
  extractFileDirFileName (libName, dirName, fName);
  lock(libMutex);
  rc = libloader(dirName, fName, msgBuf, msgBufSize);
  unlock(libMutex);
  return rc;
} /* palGetReadyL */

int palCreate (palHandle_t *ppal, char *msgBuf, int msgBufSize)
{
  int palIsReady;

  palIsReady = palGetReady (msgBuf, msgBufSize);
  if (! palIsReady) {
    return 0;
  }
  assert(palXCreate);
  palXCreate(ppal);
  if(ppal == NULL)
  { strcpy(msgBuf,"Error while creating object"); return 0; }
  lock(objMutex);
  objectCount++;
  unlock(objMutex);
  return 1;                     /* return true on successful library load */
} /* palCreate */

int palCreateD (palHandle_t *ppal, const char *dirName,
                char *msgBuf, int msgBufSize)
{
  int palIsReady;

  palIsReady = palGetReadyD (dirName, msgBuf, msgBufSize);
  if (! palIsReady) {
    return 0;
  }
  assert(palXCreate);
  palXCreate(ppal);
  if(ppal == NULL)
  { strcpy(msgBuf,"Error while creating object"); return 0; }
  lock(objMutex);
  objectCount++;
  unlock(objMutex);
  return 1;                     /* return true on successful library load */
} /* palCreateD */

int palCreateL (palHandle_t *ppal, const char *libName,
                char *msgBuf, int msgBufSize)
{
  int palIsReady;

  palIsReady = palGetReadyL (libName, msgBuf, msgBufSize);
  if (! palIsReady) {
    return 0;
  }
  assert(palXCreate);
  palXCreate(ppal);
  if(ppal == NULL)
  { strcpy(msgBuf,"Error while creating object"); return 0; }
  lock(objMutex);
  objectCount++;
  unlock(objMutex);
  return 1;                     /* return true on successful library load */
} /* palCreateL */

int palFree   (palHandle_t *ppal)
{
  assert(palXFree);
  palXFree(ppal); ppal = NULL;
  lock(objMutex);
  objectCount--;
  unlock(objMutex);
  return 1;
} /* palFree */

int palLibraryLoaded(void)
{
  int rc;
  lock(libMutex);
  rc = isLoaded;
  unlock(libMutex);
  return rc;
} /* palLibraryLoaded */

int palLibraryUnload(void)
{
  lock(objMutex);
  if (objectCount > 0)
  {
    unlock(objMutex);
    return 0;
  }
  unlock(objMutex);
  lock(libMutex);
  if (isLoaded)
  {
    isLoaded = 0;
    (void) unLoadLib(h);
  }
  unlock(libMutex);
  return 1;
} /* palLibraryUnload */

int  palCorrectLibraryVersion(char *msgBuf, int msgBufLen)
{
  int cl;
  char localBuf[256];

  if (msgBuf && msgBufLen) msgBuf[0] = '\0';

  if (! isLoaded) {
    strncpy(msgBuf, "Library needs to be initialized first", msgBufLen);
    return 0;
  }

  if (NULL == palXAPIVersion) {
    strncpy(msgBuf, "Function palXAPIVersion not found", msgBufLen);
    return 0;
  }

  palXAPIVersion(PALAPIVERSION,localBuf,&cl);
  strncpy(msgBuf, localBuf, msgBufLen);

  if (1 == cl)
    return 1;
  else
    return 0;
}

int palGetScreenIndicator(void)
{
  return ScreenIndicator;
}

void palSetScreenIndicator(int scrind)
{
  ScreenIndicator = scrind ? 1 : 0;
}

int palGetExceptionIndicator(void)
{
   return ExceptionIndicator;
}

void palSetExceptionIndicator(int excind)
{
  ExceptionIndicator = excind ? 1 : 0;
}

int palGetExitIndicator(void)
{
  return ExitIndicator;
}

void palSetExitIndicator(int extind)
{
  ExitIndicator = extind ? 1 : 0;
}

palErrorCallback_t palGetErrorCallback(void)
{
  return ErrorCallBack;
}

void palSetErrorCallback(palErrorCallback_t func)
{
  lock(exceptMutex);
  ErrorCallBack = func;
  unlock(exceptMutex);
}

int palGetAPIErrorCount(void)
{
  return APIErrorCount;
}

void palSetAPIErrorCount(int ecnt)
{
  APIErrorCount = ecnt;
}

void palErrorHandling(const char *msg)
{
  APIErrorCount++;
  if (ScreenIndicator) { printf("%s\n", msg); fflush(stdout); }
  lock(exceptMutex);
  if (ErrorCallBack)
    if (ErrorCallBack(APIErrorCount, msg)) { unlock(exceptMutex); exit(123); }
  unlock(exceptMutex);
  assert(!ExceptionIndicator);
  if (ExitIndicator) exit(123);
}

